//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IFormGuideClient {
    /**
     * @return Success
     */
    formGuideGET(): Observable<FormControlValidationMessages>;
}

@Injectable()
export class FormGuideClient implements IFormGuideClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    formGuideGET(): Observable<FormControlValidationMessages> {
        let url_ = this.baseUrl + "/api/v1/FormGuide";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFormGuideGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFormGuideGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FormControlValidationMessages>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FormControlValidationMessages>;
        }));
    }

    protected processFormGuideGET(response: HttpResponseBase): Observable<FormControlValidationMessages> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormControlValidationMessages.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ILocationClient {
    /**
     * @param body (optional) 
     * @return Created
     */
    locationPOST(body: Location | undefined): Observable<Location>;
    /**
     * @return Success
     */
    locationAll(): Observable<Location[]>;
    /**
     * @return Success
     */
    locationGET(id: number): Observable<Location>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    locationPUT(id: number, body: Location | undefined): Observable<void>;
    /**
     * @return No Content
     */
    locationDELETE(id: number): Observable<void>;
}

@Injectable()
export class LocationClient implements ILocationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    locationPOST(body: Location | undefined): Observable<Location> {
        let url_ = this.baseUrl + "/api/v1/Location";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLocationPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLocationPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Location>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Location>;
        }));
    }

    protected processLocationPOST(response: HttpResponseBase): Observable<Location> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Location.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    locationAll(): Observable<Location[]> {
        let url_ = this.baseUrl + "/api/v1/Location";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLocationAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLocationAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Location[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Location[]>;
        }));
    }

    protected processLocationAll(response: HttpResponseBase): Observable<Location[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Location.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    locationGET(id: number): Observable<Location> {
        let url_ = this.baseUrl + "/api/v1/Location/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLocationGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLocationGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Location>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Location>;
        }));
    }

    protected processLocationGET(response: HttpResponseBase): Observable<Location> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Location.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    locationPUT(id: number, body: Location | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Location/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLocationPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLocationPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLocationPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    locationDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Location/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLocationDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLocationDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLocationDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWeatherClient {
    /**
     * @param body (optional) 
     * @return Created
     */
    weatherPOST(body: Weather | undefined): Observable<Weather>;
    /**
     * @return Success
     */
    weatherAll(): Observable<Weather[]>;
    /**
     * @return Success
     */
    weatherGET(id: number): Observable<Weather>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    weatherPUT(id: number, body: Weather | undefined): Observable<void>;
    /**
     * @return No Content
     */
    weatherDELETE(id: number): Observable<void>;
}

@Injectable()
export class WeatherClient implements IWeatherClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    weatherPOST(body: Weather | undefined): Observable<Weather> {
        let url_ = this.baseUrl + "/api/v1/Weather";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Weather>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Weather>;
        }));
    }

    protected processWeatherPOST(response: HttpResponseBase): Observable<Weather> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Weather.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    weatherAll(): Observable<Weather[]> {
        let url_ = this.baseUrl + "/api/v1/Weather";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Weather[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Weather[]>;
        }));
    }

    protected processWeatherAll(response: HttpResponseBase): Observable<Weather[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Weather.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    weatherGET(id: number): Observable<Weather> {
        let url_ = this.baseUrl + "/api/v1/Weather/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Weather>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Weather>;
        }));
    }

    protected processWeatherGET(response: HttpResponseBase): Observable<Weather> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Weather.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    weatherPUT(id: number, body: Weather | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Weather/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWeatherPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    weatherDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Weather/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWeatherDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWeatherAlertClient {
    /**
     * @param body (optional) 
     * @return Created
     */
    weatherAlertPOST(body: WeatherAlert | undefined): Observable<WeatherAlert>;
    /**
     * @return Success
     */
    weatherAlertAll(): Observable<WeatherAlert[]>;
    /**
     * @return Success
     */
    weatherAlertGET(id: number): Observable<WeatherAlert>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    weatherAlertPUT(id: number, body: WeatherAlert | undefined): Observable<void>;
    /**
     * @return No Content
     */
    weatherAlertDELETE(id: number): Observable<void>;
}

@Injectable()
export class WeatherAlertClient implements IWeatherAlertClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    weatherAlertPOST(body: WeatherAlert | undefined): Observable<WeatherAlert> {
        let url_ = this.baseUrl + "/api/v1/WeatherAlert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherAlertPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherAlertPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherAlert>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherAlert>;
        }));
    }

    protected processWeatherAlertPOST(response: HttpResponseBase): Observable<WeatherAlert> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = WeatherAlert.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    weatherAlertAll(): Observable<WeatherAlert[]> {
        let url_ = this.baseUrl + "/api/v1/WeatherAlert";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherAlertAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherAlertAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherAlert[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherAlert[]>;
        }));
    }

    protected processWeatherAlertAll(response: HttpResponseBase): Observable<WeatherAlert[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherAlert.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    weatherAlertGET(id: number): Observable<WeatherAlert> {
        let url_ = this.baseUrl + "/api/v1/WeatherAlert/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherAlertGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherAlertGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherAlert>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherAlert>;
        }));
    }

    protected processWeatherAlertGET(response: HttpResponseBase): Observable<WeatherAlert> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeatherAlert.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    weatherAlertPUT(id: number, body: WeatherAlert | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/WeatherAlert/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherAlertPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherAlertPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWeatherAlertPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    weatherAlertDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/WeatherAlert/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherAlertDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherAlertDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWeatherAlertDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWeatherAlertModifierClient {
    /**
     * @param body (optional) 
     * @return Created
     */
    weatherAlertModifierPOST(body: WeatherAlertModifier | undefined): Observable<WeatherAlertModifier>;
    /**
     * @return Success
     */
    weatherAlertModifierAll(): Observable<WeatherAlertModifier[]>;
    /**
     * @return Success
     */
    weatherAlertModifierGET(id: number): Observable<WeatherAlertModifier>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    weatherAlertModifierPUT(id: number, body: WeatherAlertModifier | undefined): Observable<void>;
    /**
     * @return No Content
     */
    weatherAlertModifierDELETE(id: number): Observable<void>;
}

@Injectable()
export class WeatherAlertModifierClient implements IWeatherAlertModifierClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    weatherAlertModifierPOST(body: WeatherAlertModifier | undefined): Observable<WeatherAlertModifier> {
        let url_ = this.baseUrl + "/api/v1/WeatherAlertModifier";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherAlertModifierPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherAlertModifierPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherAlertModifier>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherAlertModifier>;
        }));
    }

    protected processWeatherAlertModifierPOST(response: HttpResponseBase): Observable<WeatherAlertModifier> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = WeatherAlertModifier.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    weatherAlertModifierAll(): Observable<WeatherAlertModifier[]> {
        let url_ = this.baseUrl + "/api/v1/WeatherAlertModifier";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherAlertModifierAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherAlertModifierAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherAlertModifier[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherAlertModifier[]>;
        }));
    }

    protected processWeatherAlertModifierAll(response: HttpResponseBase): Observable<WeatherAlertModifier[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherAlertModifier.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    weatherAlertModifierGET(id: number): Observable<WeatherAlertModifier> {
        let url_ = this.baseUrl + "/api/v1/WeatherAlertModifier/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherAlertModifierGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherAlertModifierGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherAlertModifier>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherAlertModifier>;
        }));
    }

    protected processWeatherAlertModifierGET(response: HttpResponseBase): Observable<WeatherAlertModifier> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeatherAlertModifier.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    weatherAlertModifierPUT(id: number, body: WeatherAlertModifier | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/WeatherAlertModifier/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherAlertModifierPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherAlertModifierPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWeatherAlertModifierPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    weatherAlertModifierDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/WeatherAlertModifier/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherAlertModifierDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherAlertModifierDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWeatherAlertModifierDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWeatherEventClient {
    /**
     * @param body (optional) 
     * @return Success
     */
    formGuidePOST(body: WeatherEventFormGuideRequest | undefined): Observable<WeatherEventFormGuide>;
    /**
     * @param body (optional) 
     * @return Created
     */
    weatherEventPOST(body: WeatherEvent | undefined): Observable<WeatherEvent>;
    /**
     * @return Success
     */
    weatherEventAll(): Observable<WeatherEvent[]>;
    /**
     * @return Success
     */
    weatherEventGET(id: number): Observable<WeatherEvent>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    weatherEventPUT(id: number, body: WeatherEvent | undefined): Observable<void>;
    /**
     * @return No Content
     */
    weatherEventDELETE(id: number): Observable<void>;
}

@Injectable()
export class WeatherEventClient implements IWeatherEventClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    formGuidePOST(body: WeatherEventFormGuideRequest | undefined): Observable<WeatherEventFormGuide> {
        let url_ = this.baseUrl + "/api/v1/WeatherEvent/FormGuide";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFormGuidePOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFormGuidePOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherEventFormGuide>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherEventFormGuide>;
        }));
    }

    protected processFormGuidePOST(response: HttpResponseBase): Observable<WeatherEventFormGuide> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeatherEventFormGuide.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    weatherEventPOST(body: WeatherEvent | undefined): Observable<WeatherEvent> {
        let url_ = this.baseUrl + "/api/v1/WeatherEvent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherEventPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherEventPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherEvent>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherEvent>;
        }));
    }

    protected processWeatherEventPOST(response: HttpResponseBase): Observable<WeatherEvent> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = WeatherEvent.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    weatherEventAll(): Observable<WeatherEvent[]> {
        let url_ = this.baseUrl + "/api/v1/WeatherEvent";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherEventAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherEventAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherEvent[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherEvent[]>;
        }));
    }

    protected processWeatherEventAll(response: HttpResponseBase): Observable<WeatherEvent[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherEvent.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    weatherEventGET(id: number): Observable<WeatherEvent> {
        let url_ = this.baseUrl + "/api/v1/WeatherEvent/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherEventGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherEventGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherEvent>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherEvent>;
        }));
    }

    protected processWeatherEventGET(response: HttpResponseBase): Observable<WeatherEvent> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeatherEvent.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    weatherEventPUT(id: number, body: WeatherEvent | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/WeatherEvent/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherEventPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherEventPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWeatherEventPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    weatherEventDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/WeatherEvent/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherEventDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherEventDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWeatherEventDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWeatherExperienceClient {
    /**
     * @param body (optional) 
     * @return Created
     */
    weatherExperiencePOST(body: WeatherExperience | undefined): Observable<WeatherExperience>;
    /**
     * @return Success
     */
    weatherExperienceAll(): Observable<WeatherExperience[]>;
    /**
     * @return Success
     */
    weatherExperienceGET(id: number): Observable<WeatherExperience>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    weatherExperiencePUT(id: number, body: WeatherExperience | undefined): Observable<void>;
    /**
     * @return No Content
     */
    weatherExperienceDELETE(id: number): Observable<void>;
}

@Injectable()
export class WeatherExperienceClient implements IWeatherExperienceClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    weatherExperiencePOST(body: WeatherExperience | undefined): Observable<WeatherExperience> {
        let url_ = this.baseUrl + "/api/v1/WeatherExperience";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherExperiencePOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherExperiencePOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherExperience>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherExperience>;
        }));
    }

    protected processWeatherExperiencePOST(response: HttpResponseBase): Observable<WeatherExperience> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = WeatherExperience.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    weatherExperienceAll(): Observable<WeatherExperience[]> {
        let url_ = this.baseUrl + "/api/v1/WeatherExperience";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherExperienceAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherExperienceAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherExperience[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherExperience[]>;
        }));
    }

    protected processWeatherExperienceAll(response: HttpResponseBase): Observable<WeatherExperience[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherExperience.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    weatherExperienceGET(id: number): Observable<WeatherExperience> {
        let url_ = this.baseUrl + "/api/v1/WeatherExperience/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherExperienceGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherExperienceGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherExperience>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherExperience>;
        }));
    }

    protected processWeatherExperienceGET(response: HttpResponseBase): Observable<WeatherExperience> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeatherExperience.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    weatherExperiencePUT(id: number, body: WeatherExperience | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/WeatherExperience/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherExperiencePUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherExperiencePUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWeatherExperiencePUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    weatherExperienceDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/WeatherExperience/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherExperienceDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherExperienceDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWeatherExperienceDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class DateTimeOffsetFormControlValidation implements IDateTimeOffsetFormControlValidation {
    public minValue?: Date;
    public maxValue?: Date;

    constructor(data?: IDateTimeOffsetFormControlValidation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new DateTimeOffsetFormControlValidation instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new DateTimeOffsetFormControlValidation.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.minValue = _data["minValue"] ? new Date(_data["minValue"].toString()) : <any>null;
            this.maxValue = _data["maxValue"] ? new Date(_data["maxValue"].toString()) : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this DateTimeOffsetFormControlValidation.
    * @param data Any object that holds the necessary properties to initialize a new DateTimeOffsetFormControlValidation.
    * @returns A deserialized DateTimeOffsetFormControlValidation.
    **/
    public static fromJS(data: any): DateTimeOffsetFormControlValidation {
        data = typeof data === 'object' ? data : {};
        let result = new DateTimeOffsetFormControlValidation();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this DateTimeOffsetFormControlValidation.
    * @returns A serialized DateTimeOffsetFormControlValidation.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minValue"] = this.minValue ? this.minValue.toISOString() : <any>null;
        data["maxValue"] = this.maxValue ? this.maxValue.toISOString() : <any>null;
        return data;
    }
}

export interface IDateTimeOffsetFormControlValidation {
    minValue?: Date;
    maxValue?: Date;
}

export class FormControlGuide implements IFormControlGuide {
    public validation!: FormControlValidation;
    public readOnly!: boolean;
    public hidden!: boolean;
    public defaultValue!: any;
    public suppliedValues!: FormControlValue[];

    constructor(data?: IFormControlGuide) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.validation = data.validation && !(<any>data.validation).toJSON ? new FormControlValidation(data.validation) : <FormControlValidation>this.validation;
            if (data.suppliedValues) {
                this.suppliedValues = [];
                for (let i = 0; i < data.suppliedValues.length; i++) {
                    let item = data.suppliedValues[i];
                    this.suppliedValues[i] = item && !(<any>item).toJSON ? new FormControlValue(item) : <FormControlValue>item;
                }
            }
        }
        if (!data) {
            this.validation = new FormControlValidation();
            this.suppliedValues = [];
        }
    }

    /**
    * Initializes a new FormControlGuide instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new FormControlGuide.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.validation = _data["validation"] ? FormControlValidation.fromJS(_data["validation"]) : new FormControlValidation();
            this.readOnly = _data["readOnly"] !== undefined ? _data["readOnly"] : <any>null;
            this.hidden = _data["hidden"] !== undefined ? _data["hidden"] : <any>null;
            this.defaultValue = _data["defaultValue"] !== undefined ? _data["defaultValue"] : <any>null;
            if (Array.isArray(_data["suppliedValues"])) {
                this.suppliedValues = [] as any;
                for (let item of _data["suppliedValues"])
                    this.suppliedValues!.push(FormControlValue.fromJS(item));
            }
            else {
                this.suppliedValues = <any>null;
            }
        }
    }

    /**
    * Deserializes a JSON representation of this FormControlGuide.
    * @param data Any object that holds the necessary properties to initialize a new FormControlGuide.
    * @returns A deserialized FormControlGuide.
    **/
    public static fromJS(data: any): FormControlGuide {
        data = typeof data === 'object' ? data : {};
        let result = new FormControlGuide();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this FormControlGuide.
    * @returns A serialized FormControlGuide.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["validation"] = this.validation ? this.validation.toJSON() : <any>null;
        data["readOnly"] = this.readOnly !== undefined ? this.readOnly : <any>null;
        data["hidden"] = this.hidden !== undefined ? this.hidden : <any>null;
        data["defaultValue"] = this.defaultValue !== undefined ? this.defaultValue : <any>null;
        if (Array.isArray(this.suppliedValues)) {
            data["suppliedValues"] = [];
            for (let item of this.suppliedValues)
                data["suppliedValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFormControlGuide {
    validation: IFormControlValidation;
    readOnly: boolean;
    hidden: boolean;
    defaultValue: any;
    suppliedValues: IFormControlValue[];
}

export class FormControlValidation implements IFormControlValidation {
    public required?: boolean;
    public pattern?: string | null;
    public stringValidation?: StringFormControlValidation;
    public numericValidation?: NumericFormControlValidation;
    public dateTimeValidation?: DateTimeOffsetFormControlValidation;

    constructor(data?: IFormControlValidation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.stringValidation = data.stringValidation && !(<any>data.stringValidation).toJSON ? new StringFormControlValidation(data.stringValidation) : <StringFormControlValidation>this.stringValidation;
            this.numericValidation = data.numericValidation && !(<any>data.numericValidation).toJSON ? new NumericFormControlValidation(data.numericValidation) : <NumericFormControlValidation>this.numericValidation;
            this.dateTimeValidation = data.dateTimeValidation && !(<any>data.dateTimeValidation).toJSON ? new DateTimeOffsetFormControlValidation(data.dateTimeValidation) : <DateTimeOffsetFormControlValidation>this.dateTimeValidation;
        }
    }

    /**
    * Initializes a new FormControlValidation instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new FormControlValidation.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.required = _data["required"] !== undefined ? _data["required"] : <any>null;
            this.pattern = _data["pattern"] !== undefined ? _data["pattern"] : <any>null;
            this.stringValidation = _data["stringValidation"] ? StringFormControlValidation.fromJS(_data["stringValidation"]) : <any>null;
            this.numericValidation = _data["numericValidation"] ? NumericFormControlValidation.fromJS(_data["numericValidation"]) : <any>null;
            this.dateTimeValidation = _data["dateTimeValidation"] ? DateTimeOffsetFormControlValidation.fromJS(_data["dateTimeValidation"]) : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this FormControlValidation.
    * @param data Any object that holds the necessary properties to initialize a new FormControlValidation.
    * @returns A deserialized FormControlValidation.
    **/
    public static fromJS(data: any): FormControlValidation {
        data = typeof data === 'object' ? data : {};
        let result = new FormControlValidation();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this FormControlValidation.
    * @returns A serialized FormControlValidation.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["required"] = this.required !== undefined ? this.required : <any>null;
        data["pattern"] = this.pattern !== undefined ? this.pattern : <any>null;
        data["stringValidation"] = this.stringValidation ? this.stringValidation.toJSON() : <any>null;
        data["numericValidation"] = this.numericValidation ? this.numericValidation.toJSON() : <any>null;
        data["dateTimeValidation"] = this.dateTimeValidation ? this.dateTimeValidation.toJSON() : <any>null;
        return data;
    }
}

export interface IFormControlValidation {
    required?: boolean;
    pattern?: string | null;
    stringValidation?: IStringFormControlValidation;
    numericValidation?: INumericFormControlValidation;
    dateTimeValidation?: IDateTimeOffsetFormControlValidation;
}

export class FormControlValidationMessages implements IFormControlValidationMessages {
    public readonly errorMaxDate!: string;
    public readonly errorMaxLength!: string;
    public readonly errorMaxValue!: string;
    public readonly errorMinDate!: string;
    public readonly errorMinLength!: string;
    public readonly errorMinValue!: string;
    public readonly errorPattern!: string;
    public readonly errorRangeDate!: string;
    public readonly errorRangeLength!: string;
    public readonly errorRangeValue!: string;
    public readonly errorRequired!: string;

    constructor(data?: IFormControlValidationMessages) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new FormControlValidationMessages instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new FormControlValidationMessages.
    **/
    protected init(_data?: any) {
        if (_data) {
            (<any>this).errorMaxDate = _data["errorMaxDate"] !== undefined ? _data["errorMaxDate"] : <any>null;
            (<any>this).errorMaxLength = _data["errorMaxLength"] !== undefined ? _data["errorMaxLength"] : <any>null;
            (<any>this).errorMaxValue = _data["errorMaxValue"] !== undefined ? _data["errorMaxValue"] : <any>null;
            (<any>this).errorMinDate = _data["errorMinDate"] !== undefined ? _data["errorMinDate"] : <any>null;
            (<any>this).errorMinLength = _data["errorMinLength"] !== undefined ? _data["errorMinLength"] : <any>null;
            (<any>this).errorMinValue = _data["errorMinValue"] !== undefined ? _data["errorMinValue"] : <any>null;
            (<any>this).errorPattern = _data["errorPattern"] !== undefined ? _data["errorPattern"] : <any>null;
            (<any>this).errorRangeDate = _data["errorRangeDate"] !== undefined ? _data["errorRangeDate"] : <any>null;
            (<any>this).errorRangeLength = _data["errorRangeLength"] !== undefined ? _data["errorRangeLength"] : <any>null;
            (<any>this).errorRangeValue = _data["errorRangeValue"] !== undefined ? _data["errorRangeValue"] : <any>null;
            (<any>this).errorRequired = _data["errorRequired"] !== undefined ? _data["errorRequired"] : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this FormControlValidationMessages.
    * @param data Any object that holds the necessary properties to initialize a new FormControlValidationMessages.
    * @returns A deserialized FormControlValidationMessages.
    **/
    public static fromJS(data: any): FormControlValidationMessages {
        data = typeof data === 'object' ? data : {};
        let result = new FormControlValidationMessages();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this FormControlValidationMessages.
    * @returns A serialized FormControlValidationMessages.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMaxDate"] = this.errorMaxDate !== undefined ? this.errorMaxDate : <any>null;
        data["errorMaxLength"] = this.errorMaxLength !== undefined ? this.errorMaxLength : <any>null;
        data["errorMaxValue"] = this.errorMaxValue !== undefined ? this.errorMaxValue : <any>null;
        data["errorMinDate"] = this.errorMinDate !== undefined ? this.errorMinDate : <any>null;
        data["errorMinLength"] = this.errorMinLength !== undefined ? this.errorMinLength : <any>null;
        data["errorMinValue"] = this.errorMinValue !== undefined ? this.errorMinValue : <any>null;
        data["errorPattern"] = this.errorPattern !== undefined ? this.errorPattern : <any>null;
        data["errorRangeDate"] = this.errorRangeDate !== undefined ? this.errorRangeDate : <any>null;
        data["errorRangeLength"] = this.errorRangeLength !== undefined ? this.errorRangeLength : <any>null;
        data["errorRangeValue"] = this.errorRangeValue !== undefined ? this.errorRangeValue : <any>null;
        data["errorRequired"] = this.errorRequired !== undefined ? this.errorRequired : <any>null;
        return data;
    }
}

export interface IFormControlValidationMessages {
    errorMaxDate: string;
    errorMaxLength: string;
    errorMaxValue: string;
    errorMinDate: string;
    errorMinLength: string;
    errorMinValue: string;
    errorPattern: string;
    errorRangeDate: string;
    errorRangeLength: string;
    errorRangeValue: string;
    errorRequired: string;
}

export class FormControlValue implements IFormControlValue {
    public name!: string;
    public value!: any;

    constructor(data?: IFormControlValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new FormControlValue instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new FormControlValue.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this FormControlValue.
    * @param data Any object that holds the necessary properties to initialize a new FormControlValue.
    * @returns A deserialized FormControlValue.
    **/
    public static fromJS(data: any): FormControlValue {
        data = typeof data === 'object' ? data : {};
        let result = new FormControlValue();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this FormControlValue.
    * @returns A serialized FormControlValue.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IFormControlValue {
    name: string;
    value: any;
}

export class FormGuideContext implements IFormGuideContext {
    public attributes!: { [key: string]: any; };

    constructor(data?: IFormGuideContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.attributes = {};
        }
    }

    /**
    * Initializes a new FormGuideContext instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new FormGuideContext.
    **/
    protected init(_data?: any) {
        if (_data) {
            if (_data["attributes"]) {
                this.attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>this.attributes)![key] = _data["attributes"][key] !== undefined ? _data["attributes"][key] : <any>null;
                }
            }
            else {
                this.attributes = <any>null;
            }
        }
    }

    /**
    * Deserializes a JSON representation of this FormGuideContext.
    * @param data Any object that holds the necessary properties to initialize a new FormGuideContext.
    * @returns A deserialized FormGuideContext.
    **/
    public static fromJS(data: any): FormGuideContext {
        data = typeof data === 'object' ? data : {};
        let result = new FormGuideContext();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this FormGuideContext.
    * @returns A serialized FormGuideContext.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    (<any>data["attributes"])[key] = this.attributes[key] !== undefined ? this.attributes[key] : <any>null;
            }
        }
        return data;
    }
}

export interface IFormGuideContext {
    attributes: { [key: string]: any; };
}

export class Location implements ILocation {
    public id?: number | null;
    public deleted!: boolean;
    public city!: string;
    public country!: string;

    constructor(data?: ILocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new Location instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new Location.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
            this.city = _data["city"] !== undefined ? _data["city"] : <any>null;
            this.country = _data["country"] !== undefined ? _data["country"] : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this Location.
    * @param data Any object that holds the necessary properties to initialize a new Location.
    * @returns A deserialized Location.
    **/
    public static fromJS(data: any): Location {
        data = typeof data === 'object' ? data : {};
        let result = new Location();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this Location.
    * @returns A serialized Location.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["city"] = this.city !== undefined ? this.city : <any>null;
        data["country"] = this.country !== undefined ? this.country : <any>null;
        return data;
    }
}

export interface ILocation {
    id?: number | null;
    deleted: boolean;
    city: string;
    country: string;
}

export class LocationFormGuide implements ILocationFormGuide {
    public city!: FormControlGuide;
    public country!: FormControlGuide;

    constructor(data?: ILocationFormGuide) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.city = data.city && !(<any>data.city).toJSON ? new FormControlGuide(data.city) : <FormControlGuide>this.city;
            this.country = data.country && !(<any>data.country).toJSON ? new FormControlGuide(data.country) : <FormControlGuide>this.country;
        }
        if (!data) {
            this.city = new FormControlGuide();
            this.country = new FormControlGuide();
        }
    }

    /**
    * Initializes a new LocationFormGuide instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new LocationFormGuide.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.city = _data["city"] ? FormControlGuide.fromJS(_data["city"]) : new FormControlGuide();
            this.country = _data["country"] ? FormControlGuide.fromJS(_data["country"]) : new FormControlGuide();
        }
    }

    /**
    * Deserializes a JSON representation of this LocationFormGuide.
    * @param data Any object that holds the necessary properties to initialize a new LocationFormGuide.
    * @returns A deserialized LocationFormGuide.
    **/
    public static fromJS(data: any): LocationFormGuide {
        data = typeof data === 'object' ? data : {};
        let result = new LocationFormGuide();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this LocationFormGuide.
    * @returns A serialized LocationFormGuide.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["city"] = this.city ? this.city.toJSON() : <any>null;
        data["country"] = this.country ? this.country.toJSON() : <any>null;
        return data;
    }
}

export interface ILocationFormGuide {
    city: IFormControlGuide;
    country: IFormControlGuide;
}

export class NumericFormControlValidation implements INumericFormControlValidation {
    public minValue?: number;
    public maxValue?: number;

    constructor(data?: INumericFormControlValidation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new NumericFormControlValidation instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new NumericFormControlValidation.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.minValue = _data["minValue"] !== undefined ? _data["minValue"] : <any>null;
            this.maxValue = _data["maxValue"] !== undefined ? _data["maxValue"] : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this NumericFormControlValidation.
    * @param data Any object that holds the necessary properties to initialize a new NumericFormControlValidation.
    * @returns A deserialized NumericFormControlValidation.
    **/
    public static fromJS(data: any): NumericFormControlValidation {
        data = typeof data === 'object' ? data : {};
        let result = new NumericFormControlValidation();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this NumericFormControlValidation.
    * @returns A serialized NumericFormControlValidation.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minValue"] = this.minValue !== undefined ? this.minValue : <any>null;
        data["maxValue"] = this.maxValue !== undefined ? this.maxValue : <any>null;
        return data;
    }
}

export interface INumericFormControlValidation {
    minValue?: number;
    maxValue?: number;
}

export class ProblemDetails implements IProblemDetails {
    public type?: string | null;
    public title?: string | null;
    public status?: number | null;
    public detail?: string | null;
    public instance?: string | null;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new ProblemDetails instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new ProblemDetails.
    **/
    protected init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.detail = _data["detail"] !== undefined ? _data["detail"] : <any>null;
            this.instance = _data["instance"] !== undefined ? _data["instance"] : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this ProblemDetails.
    * @param data Any object that holds the necessary properties to initialize a new ProblemDetails.
    * @returns A deserialized ProblemDetails.
    **/
    public static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this ProblemDetails.
    * @returns A serialized ProblemDetails.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["detail"] = this.detail !== undefined ? this.detail : <any>null;
        data["instance"] = this.instance !== undefined ? this.instance : <any>null;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;

    [key: string]: any;
}

export class StringFormControlValidation implements IStringFormControlValidation {
    public minLength?: number;
    public maxLength?: number;

    constructor(data?: IStringFormControlValidation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new StringFormControlValidation instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new StringFormControlValidation.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.minLength = _data["minLength"] !== undefined ? _data["minLength"] : <any>null;
            this.maxLength = _data["maxLength"] !== undefined ? _data["maxLength"] : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this StringFormControlValidation.
    * @param data Any object that holds the necessary properties to initialize a new StringFormControlValidation.
    * @returns A deserialized StringFormControlValidation.
    **/
    public static fromJS(data: any): StringFormControlValidation {
        data = typeof data === 'object' ? data : {};
        let result = new StringFormControlValidation();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this StringFormControlValidation.
    * @returns A serialized StringFormControlValidation.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minLength"] = this.minLength !== undefined ? this.minLength : <any>null;
        data["maxLength"] = this.maxLength !== undefined ? this.maxLength : <any>null;
        return data;
    }
}

export interface IStringFormControlValidation {
    minLength?: number;
    maxLength?: number;
}

export class Weather implements IWeather {
    public id?: number | null;
    public deleted!: boolean;
    public name!: string;
    public description!: string;

    constructor(data?: IWeather) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new Weather instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new Weather.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this Weather.
    * @param data Any object that holds the necessary properties to initialize a new Weather.
    * @returns A deserialized Weather.
    **/
    public static fromJS(data: any): Weather {
        data = typeof data === 'object' ? data : {};
        let result = new Weather();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this Weather.
    * @returns A serialized Weather.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export interface IWeather {
    id?: number | null;
    deleted: boolean;
    name: string;
    description: string;
}

export class WeatherAlert implements IWeatherAlert {
    public id?: number | null;
    public deleted!: boolean;
    public name!: string;
    public description!: string;
    public value!: number;
    public isThirdParty!: boolean;

    constructor(data?: IWeatherAlert) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new WeatherAlert instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherAlert.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
            this.isThirdParty = _data["isThirdParty"] !== undefined ? _data["isThirdParty"] : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherAlert.
    * @param data Any object that holds the necessary properties to initialize a new WeatherAlert.
    * @returns A deserialized WeatherAlert.
    **/
    public static fromJS(data: any): WeatherAlert {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherAlert();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherAlert.
    * @returns A serialized WeatherAlert.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        data["isThirdParty"] = this.isThirdParty !== undefined ? this.isThirdParty : <any>null;
        return data;
    }
}

export interface IWeatherAlert {
    id?: number | null;
    deleted: boolean;
    name: string;
    description: string;
    value: number;
    isThirdParty: boolean;
}

export class WeatherAlertModifier implements IWeatherAlertModifier {
    public id?: number | null;
    public deleted!: boolean;
    public name!: string;
    public description!: string;
    public bonus!: number;
    public operation!: WeatherAlertModifierOperation;

    constructor(data?: IWeatherAlertModifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new WeatherAlertModifier instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherAlertModifier.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.bonus = _data["bonus"] !== undefined ? _data["bonus"] : <any>null;
            this.operation = _data["operation"] !== undefined ? _data["operation"] : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherAlertModifier.
    * @param data Any object that holds the necessary properties to initialize a new WeatherAlertModifier.
    * @returns A deserialized WeatherAlertModifier.
    **/
    public static fromJS(data: any): WeatherAlertModifier {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherAlertModifier();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherAlertModifier.
    * @returns A serialized WeatherAlertModifier.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["bonus"] = this.bonus !== undefined ? this.bonus : <any>null;
        data["operation"] = this.operation !== undefined ? this.operation : <any>null;
        return data;
    }
}

export interface IWeatherAlertModifier {
    id?: number | null;
    deleted: boolean;
    name: string;
    description: string;
    bonus: number;
    operation: WeatherAlertModifierOperation;
}

export enum WeatherAlertModifierOperation {
    Add = "Add",
    Multiply = "Multiply",
    Set = "Set",
}

export class WeatherEvent implements IWeatherEvent {
    public id?: number | null;
    public deleted!: boolean;
    public name!: string;
    public startDate!: Date;
    public weather!: Weather;
    public experience!: WeatherExperience;
    public statistics!: WeatherEventStatistics;
    public locations!: WeatherEventLocation[];
    public alerts!: WeatherEventAlert[];
    public description?: string | null;
    public endDate?: Date | null;

    constructor(data?: IWeatherEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.weather = data.weather && !(<any>data.weather).toJSON ? new Weather(data.weather) : <Weather>this.weather;
            this.experience = data.experience && !(<any>data.experience).toJSON ? new WeatherExperience(data.experience) : <WeatherExperience>this.experience;
            this.statistics = data.statistics && !(<any>data.statistics).toJSON ? new WeatherEventStatistics(data.statistics) : <WeatherEventStatistics>this.statistics;
            if (data.locations) {
                this.locations = [];
                for (let i = 0; i < data.locations.length; i++) {
                    let item = data.locations[i];
                    this.locations[i] = item && !(<any>item).toJSON ? new WeatherEventLocation(item) : <WeatherEventLocation>item;
                }
            }
            if (data.alerts) {
                this.alerts = [];
                for (let i = 0; i < data.alerts.length; i++) {
                    let item = data.alerts[i];
                    this.alerts[i] = item && !(<any>item).toJSON ? new WeatherEventAlert(item) : <WeatherEventAlert>item;
                }
            }
        }
        if (!data) {
            this.weather = new Weather();
            this.experience = new WeatherExperience();
            this.statistics = new WeatherEventStatistics();
            this.locations = [];
            this.alerts = [];
        }
    }

    /**
    * Initializes a new WeatherEvent instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherEvent.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>null;
            this.weather = _data["weather"] ? Weather.fromJS(_data["weather"]) : new Weather();
            this.experience = _data["experience"] ? WeatherExperience.fromJS(_data["experience"]) : new WeatherExperience();
            this.statistics = _data["statistics"] ? WeatherEventStatistics.fromJS(_data["statistics"]) : new WeatherEventStatistics();
            if (Array.isArray(_data["locations"])) {
                this.locations = [] as any;
                for (let item of _data["locations"])
                    this.locations!.push(WeatherEventLocation.fromJS(item));
            }
            else {
                this.locations = <any>null;
            }
            if (Array.isArray(_data["alerts"])) {
                this.alerts = [] as any;
                for (let item of _data["alerts"])
                    this.alerts!.push(WeatherEventAlert.fromJS(item));
            }
            else {
                this.alerts = <any>null;
            }
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherEvent.
    * @param data Any object that holds the necessary properties to initialize a new WeatherEvent.
    * @returns A deserialized WeatherEvent.
    **/
    public static fromJS(data: any): WeatherEvent {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherEvent();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherEvent.
    * @returns A serialized WeatherEvent.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>null;
        data["weather"] = this.weather ? this.weather.toJSON() : <any>null;
        data["experience"] = this.experience ? this.experience.toJSON() : <any>null;
        data["statistics"] = this.statistics ? this.statistics.toJSON() : <any>null;
        if (Array.isArray(this.locations)) {
            data["locations"] = [];
            for (let item of this.locations)
                data["locations"].push(item.toJSON());
        }
        if (Array.isArray(this.alerts)) {
            data["alerts"] = [];
            for (let item of this.alerts)
                data["alerts"].push(item.toJSON());
        }
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>null;
        return data;
    }
}

export interface IWeatherEvent {
    id?: number | null;
    deleted: boolean;
    name: string;
    startDate: Date;
    weather: IWeather;
    experience: IWeatherExperience;
    statistics: IWeatherEventStatistics;
    locations: IWeatherEventLocation[];
    alerts: IWeatherEventAlert[];
    description?: string | null;
    endDate?: Date | null;
}

export class WeatherEventAlert implements IWeatherEventAlert {
    public id?: number | null;
    public deleted!: boolean;
    public alert!: WeatherAlert;
    public issuanceTime!: Date;
    public modifiers!: WeatherEventAlertModifier[];

    constructor(data?: IWeatherEventAlert) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.alert = data.alert && !(<any>data.alert).toJSON ? new WeatherAlert(data.alert) : <WeatherAlert>this.alert;
            if (data.modifiers) {
                this.modifiers = [];
                for (let i = 0; i < data.modifiers.length; i++) {
                    let item = data.modifiers[i];
                    this.modifiers[i] = item && !(<any>item).toJSON ? new WeatherEventAlertModifier(item) : <WeatherEventAlertModifier>item;
                }
            }
        }
        if (!data) {
            this.alert = new WeatherAlert();
            this.modifiers = [];
        }
    }

    /**
    * Initializes a new WeatherEventAlert instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherEventAlert.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
            this.alert = _data["alert"] ? WeatherAlert.fromJS(_data["alert"]) : new WeatherAlert();
            this.issuanceTime = _data["issuanceTime"] ? new Date(_data["issuanceTime"].toString()) : <any>null;
            if (Array.isArray(_data["modifiers"])) {
                this.modifiers = [] as any;
                for (let item of _data["modifiers"])
                    this.modifiers!.push(WeatherEventAlertModifier.fromJS(item));
            }
            else {
                this.modifiers = <any>null;
            }
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherEventAlert.
    * @param data Any object that holds the necessary properties to initialize a new WeatherEventAlert.
    * @returns A deserialized WeatherEventAlert.
    **/
    public static fromJS(data: any): WeatherEventAlert {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherEventAlert();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherEventAlert.
    * @returns A serialized WeatherEventAlert.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["alert"] = this.alert ? this.alert.toJSON() : <any>null;
        data["issuanceTime"] = this.issuanceTime ? this.issuanceTime.toISOString() : <any>null;
        if (Array.isArray(this.modifiers)) {
            data["modifiers"] = [];
            for (let item of this.modifiers)
                data["modifiers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWeatherEventAlert {
    id?: number | null;
    deleted: boolean;
    alert: IWeatherAlert;
    issuanceTime: Date;
    modifiers: IWeatherEventAlertModifier[];
}

export class WeatherEventAlertFormGuide implements IWeatherEventAlertFormGuide {
    public alert!: FormControlGuide;
    public issuanceTime!: FormControlGuide;
    public modifiers!: FormControlGuide[];

    constructor(data?: IWeatherEventAlertFormGuide) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.alert = data.alert && !(<any>data.alert).toJSON ? new FormControlGuide(data.alert) : <FormControlGuide>this.alert;
            this.issuanceTime = data.issuanceTime && !(<any>data.issuanceTime).toJSON ? new FormControlGuide(data.issuanceTime) : <FormControlGuide>this.issuanceTime;
            if (data.modifiers) {
                this.modifiers = [];
                for (let i = 0; i < data.modifiers.length; i++) {
                    let item = data.modifiers[i];
                    this.modifiers[i] = item && !(<any>item).toJSON ? new FormControlGuide(item) : <FormControlGuide>item;
                }
            }
        }
        if (!data) {
            this.alert = new FormControlGuide();
            this.issuanceTime = new FormControlGuide();
            this.modifiers = [];
        }
    }

    /**
    * Initializes a new WeatherEventAlertFormGuide instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherEventAlertFormGuide.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.alert = _data["alert"] ? FormControlGuide.fromJS(_data["alert"]) : new FormControlGuide();
            this.issuanceTime = _data["issuanceTime"] ? FormControlGuide.fromJS(_data["issuanceTime"]) : new FormControlGuide();
            if (Array.isArray(_data["modifiers"])) {
                this.modifiers = [] as any;
                for (let item of _data["modifiers"])
                    this.modifiers!.push(FormControlGuide.fromJS(item));
            }
            else {
                this.modifiers = <any>null;
            }
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherEventAlertFormGuide.
    * @param data Any object that holds the necessary properties to initialize a new WeatherEventAlertFormGuide.
    * @returns A deserialized WeatherEventAlertFormGuide.
    **/
    public static fromJS(data: any): WeatherEventAlertFormGuide {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherEventAlertFormGuide();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherEventAlertFormGuide.
    * @returns A serialized WeatherEventAlertFormGuide.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alert"] = this.alert ? this.alert.toJSON() : <any>null;
        data["issuanceTime"] = this.issuanceTime ? this.issuanceTime.toJSON() : <any>null;
        if (Array.isArray(this.modifiers)) {
            data["modifiers"] = [];
            for (let item of this.modifiers)
                data["modifiers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWeatherEventAlertFormGuide {
    alert: IFormControlGuide;
    issuanceTime: IFormControlGuide;
    modifiers: IFormControlGuide[];
}

export class WeatherEventAlertModifier implements IWeatherEventAlertModifier {
    public id?: number | null;
    public deleted!: boolean;
    public modifier!: WeatherAlertModifier;

    constructor(data?: IWeatherEventAlertModifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.modifier = data.modifier && !(<any>data.modifier).toJSON ? new WeatherAlertModifier(data.modifier) : <WeatherAlertModifier>this.modifier;
        }
        if (!data) {
            this.modifier = new WeatherAlertModifier();
        }
    }

    /**
    * Initializes a new WeatherEventAlertModifier instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherEventAlertModifier.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
            this.modifier = _data["modifier"] ? WeatherAlertModifier.fromJS(_data["modifier"]) : new WeatherAlertModifier();
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherEventAlertModifier.
    * @param data Any object that holds the necessary properties to initialize a new WeatherEventAlertModifier.
    * @returns A deserialized WeatherEventAlertModifier.
    **/
    public static fromJS(data: any): WeatherEventAlertModifier {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherEventAlertModifier();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherEventAlertModifier.
    * @returns A serialized WeatherEventAlertModifier.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["modifier"] = this.modifier ? this.modifier.toJSON() : <any>null;
        return data;
    }
}

export interface IWeatherEventAlertModifier {
    id?: number | null;
    deleted: boolean;
    modifier: IWeatherAlertModifier;
}

export class WeatherEventFormGuide implements IWeatherEventFormGuide {
    public name!: FormControlGuide;
    public experience!: FormControlGuide;
    public weather!: FormControlGuide;
    public startDate!: FormControlGuide;
    public endDate!: FormControlGuide;
    public description!: FormControlGuide;
    public statistics!: WeatherEventStatisticsFormGuide;
    public locations!: WeatherEventLocationFormGuide[];
    public alerts!: WeatherEventAlertFormGuide[];

    constructor(data?: IWeatherEventFormGuide) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.name = data.name && !(<any>data.name).toJSON ? new FormControlGuide(data.name) : <FormControlGuide>this.name;
            this.experience = data.experience && !(<any>data.experience).toJSON ? new FormControlGuide(data.experience) : <FormControlGuide>this.experience;
            this.weather = data.weather && !(<any>data.weather).toJSON ? new FormControlGuide(data.weather) : <FormControlGuide>this.weather;
            this.startDate = data.startDate && !(<any>data.startDate).toJSON ? new FormControlGuide(data.startDate) : <FormControlGuide>this.startDate;
            this.endDate = data.endDate && !(<any>data.endDate).toJSON ? new FormControlGuide(data.endDate) : <FormControlGuide>this.endDate;
            this.description = data.description && !(<any>data.description).toJSON ? new FormControlGuide(data.description) : <FormControlGuide>this.description;
            this.statistics = data.statistics && !(<any>data.statistics).toJSON ? new WeatherEventStatisticsFormGuide(data.statistics) : <WeatherEventStatisticsFormGuide>this.statistics;
            if (data.locations) {
                this.locations = [];
                for (let i = 0; i < data.locations.length; i++) {
                    let item = data.locations[i];
                    this.locations[i] = item && !(<any>item).toJSON ? new WeatherEventLocationFormGuide(item) : <WeatherEventLocationFormGuide>item;
                }
            }
            if (data.alerts) {
                this.alerts = [];
                for (let i = 0; i < data.alerts.length; i++) {
                    let item = data.alerts[i];
                    this.alerts[i] = item && !(<any>item).toJSON ? new WeatherEventAlertFormGuide(item) : <WeatherEventAlertFormGuide>item;
                }
            }
        }
        if (!data) {
            this.name = new FormControlGuide();
            this.experience = new FormControlGuide();
            this.weather = new FormControlGuide();
            this.startDate = new FormControlGuide();
            this.endDate = new FormControlGuide();
            this.description = new FormControlGuide();
            this.statistics = new WeatherEventStatisticsFormGuide();
            this.locations = [];
            this.alerts = [];
        }
    }

    /**
    * Initializes a new WeatherEventFormGuide instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherEventFormGuide.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.name = _data["name"] ? FormControlGuide.fromJS(_data["name"]) : new FormControlGuide();
            this.experience = _data["experience"] ? FormControlGuide.fromJS(_data["experience"]) : new FormControlGuide();
            this.weather = _data["weather"] ? FormControlGuide.fromJS(_data["weather"]) : new FormControlGuide();
            this.startDate = _data["startDate"] ? FormControlGuide.fromJS(_data["startDate"]) : new FormControlGuide();
            this.endDate = _data["endDate"] ? FormControlGuide.fromJS(_data["endDate"]) : new FormControlGuide();
            this.description = _data["description"] ? FormControlGuide.fromJS(_data["description"]) : new FormControlGuide();
            this.statistics = _data["statistics"] ? WeatherEventStatisticsFormGuide.fromJS(_data["statistics"]) : new WeatherEventStatisticsFormGuide();
            if (Array.isArray(_data["locations"])) {
                this.locations = [] as any;
                for (let item of _data["locations"])
                    this.locations!.push(WeatherEventLocationFormGuide.fromJS(item));
            }
            else {
                this.locations = <any>null;
            }
            if (Array.isArray(_data["alerts"])) {
                this.alerts = [] as any;
                for (let item of _data["alerts"])
                    this.alerts!.push(WeatherEventAlertFormGuide.fromJS(item));
            }
            else {
                this.alerts = <any>null;
            }
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherEventFormGuide.
    * @param data Any object that holds the necessary properties to initialize a new WeatherEventFormGuide.
    * @returns A deserialized WeatherEventFormGuide.
    **/
    public static fromJS(data: any): WeatherEventFormGuide {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherEventFormGuide();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherEventFormGuide.
    * @returns A serialized WeatherEventFormGuide.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>null;
        data["experience"] = this.experience ? this.experience.toJSON() : <any>null;
        data["weather"] = this.weather ? this.weather.toJSON() : <any>null;
        data["startDate"] = this.startDate ? this.startDate.toJSON() : <any>null;
        data["endDate"] = this.endDate ? this.endDate.toJSON() : <any>null;
        data["description"] = this.description ? this.description.toJSON() : <any>null;
        data["statistics"] = this.statistics ? this.statistics.toJSON() : <any>null;
        if (Array.isArray(this.locations)) {
            data["locations"] = [];
            for (let item of this.locations)
                data["locations"].push(item.toJSON());
        }
        if (Array.isArray(this.alerts)) {
            data["alerts"] = [];
            for (let item of this.alerts)
                data["alerts"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWeatherEventFormGuide {
    name: IFormControlGuide;
    experience: IFormControlGuide;
    weather: IFormControlGuide;
    startDate: IFormControlGuide;
    endDate: IFormControlGuide;
    description: IFormControlGuide;
    statistics: IWeatherEventStatisticsFormGuide;
    locations: IWeatherEventLocationFormGuide[];
    alerts: IWeatherEventAlertFormGuide[];
}

export class WeatherEventFormGuideRequest implements IWeatherEventFormGuideRequest {
    public model!: WeatherEvent;
    public context!: FormGuideContext;

    constructor(data?: IWeatherEventFormGuideRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.model = data.model && !(<any>data.model).toJSON ? new WeatherEvent(data.model) : <WeatherEvent>this.model;
            this.context = data.context && !(<any>data.context).toJSON ? new FormGuideContext(data.context) : <FormGuideContext>this.context;
        }
        if (!data) {
            this.model = new WeatherEvent();
            this.context = new FormGuideContext();
        }
    }

    /**
    * Initializes a new WeatherEventFormGuideRequest instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherEventFormGuideRequest.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.model = _data["model"] ? WeatherEvent.fromJS(_data["model"]) : new WeatherEvent();
            this.context = _data["context"] ? FormGuideContext.fromJS(_data["context"]) : new FormGuideContext();
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherEventFormGuideRequest.
    * @param data Any object that holds the necessary properties to initialize a new WeatherEventFormGuideRequest.
    * @returns A deserialized WeatherEventFormGuideRequest.
    **/
    public static fromJS(data: any): WeatherEventFormGuideRequest {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherEventFormGuideRequest();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherEventFormGuideRequest.
    * @returns A serialized WeatherEventFormGuideRequest.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["model"] = this.model ? this.model.toJSON() : <any>null;
        data["context"] = this.context ? this.context.toJSON() : <any>null;
        return data;
    }
}

export interface IWeatherEventFormGuideRequest {
    model: IWeatherEvent;
    context: IFormGuideContext;
}

export class WeatherEventLocation implements IWeatherEventLocation {
    public id?: number | null;
    public deleted!: boolean;
    public location!: Location;
    public startTime!: Date;
    public endTime!: Date;

    constructor(data?: IWeatherEventLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.location = data.location && !(<any>data.location).toJSON ? new Location(data.location) : <Location>this.location;
        }
        if (!data) {
            this.location = new Location();
        }
    }

    /**
    * Initializes a new WeatherEventLocation instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherEventLocation.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
            this.location = _data["location"] ? Location.fromJS(_data["location"]) : new Location();
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>null;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherEventLocation.
    * @param data Any object that holds the necessary properties to initialize a new WeatherEventLocation.
    * @returns A deserialized WeatherEventLocation.
    **/
    public static fromJS(data: any): WeatherEventLocation {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherEventLocation();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherEventLocation.
    * @returns A serialized WeatherEventLocation.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["location"] = this.location ? this.location.toJSON() : <any>null;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>null;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>null;
        return data;
    }
}

export interface IWeatherEventLocation {
    id?: number | null;
    deleted: boolean;
    location: ILocation;
    startTime: Date;
    endTime: Date;
}

export class WeatherEventLocationFormGuide implements IWeatherEventLocationFormGuide {
    public startTime!: FormControlGuide;
    public endTime!: FormControlGuide;
    public location!: LocationFormGuide;

    constructor(data?: IWeatherEventLocationFormGuide) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.startTime = data.startTime && !(<any>data.startTime).toJSON ? new FormControlGuide(data.startTime) : <FormControlGuide>this.startTime;
            this.endTime = data.endTime && !(<any>data.endTime).toJSON ? new FormControlGuide(data.endTime) : <FormControlGuide>this.endTime;
            this.location = data.location && !(<any>data.location).toJSON ? new LocationFormGuide(data.location) : <LocationFormGuide>this.location;
        }
        if (!data) {
            this.startTime = new FormControlGuide();
            this.endTime = new FormControlGuide();
            this.location = new LocationFormGuide();
        }
    }

    /**
    * Initializes a new WeatherEventLocationFormGuide instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherEventLocationFormGuide.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.startTime = _data["startTime"] ? FormControlGuide.fromJS(_data["startTime"]) : new FormControlGuide();
            this.endTime = _data["endTime"] ? FormControlGuide.fromJS(_data["endTime"]) : new FormControlGuide();
            this.location = _data["location"] ? LocationFormGuide.fromJS(_data["location"]) : new LocationFormGuide();
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherEventLocationFormGuide.
    * @param data Any object that holds the necessary properties to initialize a new WeatherEventLocationFormGuide.
    * @returns A deserialized WeatherEventLocationFormGuide.
    **/
    public static fromJS(data: any): WeatherEventLocationFormGuide {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherEventLocationFormGuide();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherEventLocationFormGuide.
    * @returns A serialized WeatherEventLocationFormGuide.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toJSON() : <any>null;
        data["endTime"] = this.endTime ? this.endTime.toJSON() : <any>null;
        data["location"] = this.location ? this.location.toJSON() : <any>null;
        return data;
    }
}

export interface IWeatherEventLocationFormGuide {
    startTime: IFormControlGuide;
    endTime: IFormControlGuide;
    location: ILocationFormGuide;
}

export class WeatherEventStatistics implements IWeatherEventStatistics {
    public id?: number | null;
    public deleted!: boolean;
    public damageCost?: number | null;
    public fatalities?: number | null;
    public efRating?: number | null;
    public pathDistance?: number | null;
    public funnelWidth?: number | null;
    public saffirSimpsonRating?: number | null;
    public lowestPressure?: number | null;
    public maxWindSpeed?: number | null;
    public richterMagnitude?: number | null;
    public mercalliIntensity?: number | null;
    public aftershocks?: number | null;
    public fault?: string | null;
    public relatedTsunami?: boolean | null;

    constructor(data?: IWeatherEventStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new WeatherEventStatistics instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherEventStatistics.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
            this.damageCost = _data["damageCost"] !== undefined ? _data["damageCost"] : <any>null;
            this.fatalities = _data["fatalities"] !== undefined ? _data["fatalities"] : <any>null;
            this.efRating = _data["efRating"] !== undefined ? _data["efRating"] : <any>null;
            this.pathDistance = _data["pathDistance"] !== undefined ? _data["pathDistance"] : <any>null;
            this.funnelWidth = _data["funnelWidth"] !== undefined ? _data["funnelWidth"] : <any>null;
            this.saffirSimpsonRating = _data["saffirSimpsonRating"] !== undefined ? _data["saffirSimpsonRating"] : <any>null;
            this.lowestPressure = _data["lowestPressure"] !== undefined ? _data["lowestPressure"] : <any>null;
            this.maxWindSpeed = _data["maxWindSpeed"] !== undefined ? _data["maxWindSpeed"] : <any>null;
            this.richterMagnitude = _data["richterMagnitude"] !== undefined ? _data["richterMagnitude"] : <any>null;
            this.mercalliIntensity = _data["mercalliIntensity"] !== undefined ? _data["mercalliIntensity"] : <any>null;
            this.aftershocks = _data["aftershocks"] !== undefined ? _data["aftershocks"] : <any>null;
            this.fault = _data["fault"] !== undefined ? _data["fault"] : <any>null;
            this.relatedTsunami = _data["relatedTsunami"] !== undefined ? _data["relatedTsunami"] : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherEventStatistics.
    * @param data Any object that holds the necessary properties to initialize a new WeatherEventStatistics.
    * @returns A deserialized WeatherEventStatistics.
    **/
    public static fromJS(data: any): WeatherEventStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherEventStatistics();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherEventStatistics.
    * @returns A serialized WeatherEventStatistics.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["damageCost"] = this.damageCost !== undefined ? this.damageCost : <any>null;
        data["fatalities"] = this.fatalities !== undefined ? this.fatalities : <any>null;
        data["efRating"] = this.efRating !== undefined ? this.efRating : <any>null;
        data["pathDistance"] = this.pathDistance !== undefined ? this.pathDistance : <any>null;
        data["funnelWidth"] = this.funnelWidth !== undefined ? this.funnelWidth : <any>null;
        data["saffirSimpsonRating"] = this.saffirSimpsonRating !== undefined ? this.saffirSimpsonRating : <any>null;
        data["lowestPressure"] = this.lowestPressure !== undefined ? this.lowestPressure : <any>null;
        data["maxWindSpeed"] = this.maxWindSpeed !== undefined ? this.maxWindSpeed : <any>null;
        data["richterMagnitude"] = this.richterMagnitude !== undefined ? this.richterMagnitude : <any>null;
        data["mercalliIntensity"] = this.mercalliIntensity !== undefined ? this.mercalliIntensity : <any>null;
        data["aftershocks"] = this.aftershocks !== undefined ? this.aftershocks : <any>null;
        data["fault"] = this.fault !== undefined ? this.fault : <any>null;
        data["relatedTsunami"] = this.relatedTsunami !== undefined ? this.relatedTsunami : <any>null;
        return data;
    }
}

export interface IWeatherEventStatistics {
    id?: number | null;
    deleted: boolean;
    damageCost?: number | null;
    fatalities?: number | null;
    efRating?: number | null;
    pathDistance?: number | null;
    funnelWidth?: number | null;
    saffirSimpsonRating?: number | null;
    lowestPressure?: number | null;
    maxWindSpeed?: number | null;
    richterMagnitude?: number | null;
    mercalliIntensity?: number | null;
    aftershocks?: number | null;
    fault?: string | null;
    relatedTsunami?: boolean | null;
}

export class WeatherEventStatisticsFormGuide implements IWeatherEventStatisticsFormGuide {
    public damageCost!: FormControlGuide;
    public fatalities!: FormControlGuide;
    public efRating!: FormControlGuide;
    public pathDistance!: FormControlGuide;
    public funnelWidth!: FormControlGuide;
    public saffirSimpsonRating!: FormControlGuide;
    public lowestPressure!: FormControlGuide;
    public maxWindSpeed!: FormControlGuide;
    public richterMagnitude!: FormControlGuide;
    public mercalliIntensity!: FormControlGuide;
    public aftershocks!: FormControlGuide;
    public fault!: FormControlGuide;
    public relatedTsunami!: FormControlGuide;

    constructor(data?: IWeatherEventStatisticsFormGuide) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.damageCost = data.damageCost && !(<any>data.damageCost).toJSON ? new FormControlGuide(data.damageCost) : <FormControlGuide>this.damageCost;
            this.fatalities = data.fatalities && !(<any>data.fatalities).toJSON ? new FormControlGuide(data.fatalities) : <FormControlGuide>this.fatalities;
            this.efRating = data.efRating && !(<any>data.efRating).toJSON ? new FormControlGuide(data.efRating) : <FormControlGuide>this.efRating;
            this.pathDistance = data.pathDistance && !(<any>data.pathDistance).toJSON ? new FormControlGuide(data.pathDistance) : <FormControlGuide>this.pathDistance;
            this.funnelWidth = data.funnelWidth && !(<any>data.funnelWidth).toJSON ? new FormControlGuide(data.funnelWidth) : <FormControlGuide>this.funnelWidth;
            this.saffirSimpsonRating = data.saffirSimpsonRating && !(<any>data.saffirSimpsonRating).toJSON ? new FormControlGuide(data.saffirSimpsonRating) : <FormControlGuide>this.saffirSimpsonRating;
            this.lowestPressure = data.lowestPressure && !(<any>data.lowestPressure).toJSON ? new FormControlGuide(data.lowestPressure) : <FormControlGuide>this.lowestPressure;
            this.maxWindSpeed = data.maxWindSpeed && !(<any>data.maxWindSpeed).toJSON ? new FormControlGuide(data.maxWindSpeed) : <FormControlGuide>this.maxWindSpeed;
            this.richterMagnitude = data.richterMagnitude && !(<any>data.richterMagnitude).toJSON ? new FormControlGuide(data.richterMagnitude) : <FormControlGuide>this.richterMagnitude;
            this.mercalliIntensity = data.mercalliIntensity && !(<any>data.mercalliIntensity).toJSON ? new FormControlGuide(data.mercalliIntensity) : <FormControlGuide>this.mercalliIntensity;
            this.aftershocks = data.aftershocks && !(<any>data.aftershocks).toJSON ? new FormControlGuide(data.aftershocks) : <FormControlGuide>this.aftershocks;
            this.fault = data.fault && !(<any>data.fault).toJSON ? new FormControlGuide(data.fault) : <FormControlGuide>this.fault;
            this.relatedTsunami = data.relatedTsunami && !(<any>data.relatedTsunami).toJSON ? new FormControlGuide(data.relatedTsunami) : <FormControlGuide>this.relatedTsunami;
        }
        if (!data) {
            this.damageCost = new FormControlGuide();
            this.fatalities = new FormControlGuide();
            this.efRating = new FormControlGuide();
            this.pathDistance = new FormControlGuide();
            this.funnelWidth = new FormControlGuide();
            this.saffirSimpsonRating = new FormControlGuide();
            this.lowestPressure = new FormControlGuide();
            this.maxWindSpeed = new FormControlGuide();
            this.richterMagnitude = new FormControlGuide();
            this.mercalliIntensity = new FormControlGuide();
            this.aftershocks = new FormControlGuide();
            this.fault = new FormControlGuide();
            this.relatedTsunami = new FormControlGuide();
        }
    }

    /**
    * Initializes a new WeatherEventStatisticsFormGuide instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherEventStatisticsFormGuide.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.damageCost = _data["damageCost"] ? FormControlGuide.fromJS(_data["damageCost"]) : new FormControlGuide();
            this.fatalities = _data["fatalities"] ? FormControlGuide.fromJS(_data["fatalities"]) : new FormControlGuide();
            this.efRating = _data["efRating"] ? FormControlGuide.fromJS(_data["efRating"]) : new FormControlGuide();
            this.pathDistance = _data["pathDistance"] ? FormControlGuide.fromJS(_data["pathDistance"]) : new FormControlGuide();
            this.funnelWidth = _data["funnelWidth"] ? FormControlGuide.fromJS(_data["funnelWidth"]) : new FormControlGuide();
            this.saffirSimpsonRating = _data["saffirSimpsonRating"] ? FormControlGuide.fromJS(_data["saffirSimpsonRating"]) : new FormControlGuide();
            this.lowestPressure = _data["lowestPressure"] ? FormControlGuide.fromJS(_data["lowestPressure"]) : new FormControlGuide();
            this.maxWindSpeed = _data["maxWindSpeed"] ? FormControlGuide.fromJS(_data["maxWindSpeed"]) : new FormControlGuide();
            this.richterMagnitude = _data["richterMagnitude"] ? FormControlGuide.fromJS(_data["richterMagnitude"]) : new FormControlGuide();
            this.mercalliIntensity = _data["mercalliIntensity"] ? FormControlGuide.fromJS(_data["mercalliIntensity"]) : new FormControlGuide();
            this.aftershocks = _data["aftershocks"] ? FormControlGuide.fromJS(_data["aftershocks"]) : new FormControlGuide();
            this.fault = _data["fault"] ? FormControlGuide.fromJS(_data["fault"]) : new FormControlGuide();
            this.relatedTsunami = _data["relatedTsunami"] ? FormControlGuide.fromJS(_data["relatedTsunami"]) : new FormControlGuide();
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherEventStatisticsFormGuide.
    * @param data Any object that holds the necessary properties to initialize a new WeatherEventStatisticsFormGuide.
    * @returns A deserialized WeatherEventStatisticsFormGuide.
    **/
    public static fromJS(data: any): WeatherEventStatisticsFormGuide {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherEventStatisticsFormGuide();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherEventStatisticsFormGuide.
    * @returns A serialized WeatherEventStatisticsFormGuide.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["damageCost"] = this.damageCost ? this.damageCost.toJSON() : <any>null;
        data["fatalities"] = this.fatalities ? this.fatalities.toJSON() : <any>null;
        data["efRating"] = this.efRating ? this.efRating.toJSON() : <any>null;
        data["pathDistance"] = this.pathDistance ? this.pathDistance.toJSON() : <any>null;
        data["funnelWidth"] = this.funnelWidth ? this.funnelWidth.toJSON() : <any>null;
        data["saffirSimpsonRating"] = this.saffirSimpsonRating ? this.saffirSimpsonRating.toJSON() : <any>null;
        data["lowestPressure"] = this.lowestPressure ? this.lowestPressure.toJSON() : <any>null;
        data["maxWindSpeed"] = this.maxWindSpeed ? this.maxWindSpeed.toJSON() : <any>null;
        data["richterMagnitude"] = this.richterMagnitude ? this.richterMagnitude.toJSON() : <any>null;
        data["mercalliIntensity"] = this.mercalliIntensity ? this.mercalliIntensity.toJSON() : <any>null;
        data["aftershocks"] = this.aftershocks ? this.aftershocks.toJSON() : <any>null;
        data["fault"] = this.fault ? this.fault.toJSON() : <any>null;
        data["relatedTsunami"] = this.relatedTsunami ? this.relatedTsunami.toJSON() : <any>null;
        return data;
    }
}

export interface IWeatherEventStatisticsFormGuide {
    damageCost: IFormControlGuide;
    fatalities: IFormControlGuide;
    efRating: IFormControlGuide;
    pathDistance: IFormControlGuide;
    funnelWidth: IFormControlGuide;
    saffirSimpsonRating: IFormControlGuide;
    lowestPressure: IFormControlGuide;
    maxWindSpeed: IFormControlGuide;
    richterMagnitude: IFormControlGuide;
    mercalliIntensity: IFormControlGuide;
    aftershocks: IFormControlGuide;
    fault: IFormControlGuide;
    relatedTsunami: IFormControlGuide;
}

export class WeatherExperience implements IWeatherExperience {
    public id?: number | null;
    public deleted!: boolean;
    public name!: string;
    public description!: string;
    public startTime!: Date;
    public endTime?: Date | null;

    constructor(data?: IWeatherExperience) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new WeatherExperience instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherExperience.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>null;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherExperience.
    * @param data Any object that holds the necessary properties to initialize a new WeatherExperience.
    * @returns A deserialized WeatherExperience.
    **/
    public static fromJS(data: any): WeatherExperience {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherExperience();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherExperience.
    * @returns A serialized WeatherExperience.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>null;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>null;
        return data;
    }
}

export interface IWeatherExperience {
    id?: number | null;
    deleted: boolean;
    name: string;
    description: string;
    startTime: Date;
    endTime?: Date | null;
}

export class SkylightApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSkylightApiException = true;

    static isSkylightApiException(obj: any): obj is SkylightApiException {
        return obj.isSkylightApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SkylightApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}

// Put any type imports required for Http Clients generated by NSwag here...