//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface ILocationClient {
    /**
     * @param body (optional) 
     * @return Created
     */
    locationPOST(body: Location | undefined): Observable<Location>;
    /**
     * @return Success
     */
    locationAll(): Observable<Location[]>;
    /**
     * @return Success
     */
    locationGET(id: number): Observable<Location>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    locationPUT(id: number, body: Location | undefined): Observable<void>;
    /**
     * @return No Content
     */
    locationDELETE(id: number): Observable<void>;
}

@Injectable()
export class LocationClient implements ILocationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    locationPOST(body: Location | undefined): Observable<Location> {
        let url_ = this.baseUrl + "/api/v1/Location";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLocationPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLocationPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Location>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Location>;
        }));
    }

    protected processLocationPOST(response: HttpResponseBase): Observable<Location> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Location.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    locationAll(): Observable<Location[]> {
        let url_ = this.baseUrl + "/api/v1/Location";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLocationAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLocationAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Location[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Location[]>;
        }));
    }

    protected processLocationAll(response: HttpResponseBase): Observable<Location[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Location.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    locationGET(id: number): Observable<Location> {
        let url_ = this.baseUrl + "/api/v1/Location/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLocationGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLocationGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Location>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Location>;
        }));
    }

    protected processLocationGET(response: HttpResponseBase): Observable<Location> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Location.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    locationPUT(id: number, body: Location | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Location/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLocationPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLocationPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLocationPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    locationDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Location/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLocationDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLocationDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLocationDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWeatherClient {
    /**
     * @param body (optional) 
     * @return Created
     */
    weatherPOST(body: Weather | undefined): Observable<Weather>;
    /**
     * @return Success
     */
    weatherAll(): Observable<Weather[]>;
    /**
     * @return Success
     */
    weatherGET(id: number): Observable<Weather>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    weatherPUT(id: number, body: Weather | undefined): Observable<void>;
    /**
     * @return No Content
     */
    weatherDELETE(id: number): Observable<void>;
}

@Injectable()
export class WeatherClient implements IWeatherClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    weatherPOST(body: Weather | undefined): Observable<Weather> {
        let url_ = this.baseUrl + "/api/v1/Weather";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Weather>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Weather>;
        }));
    }

    protected processWeatherPOST(response: HttpResponseBase): Observable<Weather> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Weather.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    weatherAll(): Observable<Weather[]> {
        let url_ = this.baseUrl + "/api/v1/Weather";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Weather[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Weather[]>;
        }));
    }

    protected processWeatherAll(response: HttpResponseBase): Observable<Weather[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Weather.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    weatherGET(id: number): Observable<Weather> {
        let url_ = this.baseUrl + "/api/v1/Weather/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Weather>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Weather>;
        }));
    }

    protected processWeatherGET(response: HttpResponseBase): Observable<Weather> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Weather.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    weatherPUT(id: number, body: Weather | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Weather/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWeatherPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    weatherDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Weather/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWeatherDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWeatherAlertClient {
    /**
     * @param body (optional) 
     * @return Created
     */
    weatherAlertPOST(body: WeatherAlert | undefined): Observable<WeatherAlert>;
    /**
     * @return Success
     */
    weatherAlertAll(): Observable<WeatherAlert[]>;
    /**
     * @return Success
     */
    weatherAlertGET(id: number): Observable<WeatherAlert>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    weatherAlertPUT(id: number, body: WeatherAlert | undefined): Observable<void>;
    /**
     * @return No Content
     */
    weatherAlertDELETE(id: number): Observable<void>;
}

@Injectable()
export class WeatherAlertClient implements IWeatherAlertClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    weatherAlertPOST(body: WeatherAlert | undefined): Observable<WeatherAlert> {
        let url_ = this.baseUrl + "/api/v1/WeatherAlert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherAlertPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherAlertPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherAlert>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherAlert>;
        }));
    }

    protected processWeatherAlertPOST(response: HttpResponseBase): Observable<WeatherAlert> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = WeatherAlert.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    weatherAlertAll(): Observable<WeatherAlert[]> {
        let url_ = this.baseUrl + "/api/v1/WeatherAlert";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherAlertAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherAlertAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherAlert[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherAlert[]>;
        }));
    }

    protected processWeatherAlertAll(response: HttpResponseBase): Observable<WeatherAlert[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherAlert.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    weatherAlertGET(id: number): Observable<WeatherAlert> {
        let url_ = this.baseUrl + "/api/v1/WeatherAlert/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherAlertGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherAlertGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherAlert>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherAlert>;
        }));
    }

    protected processWeatherAlertGET(response: HttpResponseBase): Observable<WeatherAlert> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeatherAlert.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    weatherAlertPUT(id: number, body: WeatherAlert | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/WeatherAlert/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherAlertPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherAlertPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWeatherAlertPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    weatherAlertDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/WeatherAlert/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherAlertDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherAlertDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWeatherAlertDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWeatherAlertModifierClient {
    /**
     * @param body (optional) 
     * @return Created
     */
    weatherAlertModifierPOST(body: WeatherAlertModifier | undefined): Observable<WeatherAlertModifier>;
    /**
     * @return Success
     */
    weatherAlertModifierAll(): Observable<WeatherAlertModifier[]>;
    /**
     * @return Success
     */
    weatherAlertModifierGET(id: number): Observable<WeatherAlertModifier>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    weatherAlertModifierPUT(id: number, body: WeatherAlertModifier | undefined): Observable<void>;
    /**
     * @return No Content
     */
    weatherAlertModifierDELETE(id: number): Observable<void>;
}

@Injectable()
export class WeatherAlertModifierClient implements IWeatherAlertModifierClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    weatherAlertModifierPOST(body: WeatherAlertModifier | undefined): Observable<WeatherAlertModifier> {
        let url_ = this.baseUrl + "/api/v1/WeatherAlertModifier";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherAlertModifierPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherAlertModifierPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherAlertModifier>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherAlertModifier>;
        }));
    }

    protected processWeatherAlertModifierPOST(response: HttpResponseBase): Observable<WeatherAlertModifier> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = WeatherAlertModifier.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    weatherAlertModifierAll(): Observable<WeatherAlertModifier[]> {
        let url_ = this.baseUrl + "/api/v1/WeatherAlertModifier";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherAlertModifierAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherAlertModifierAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherAlertModifier[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherAlertModifier[]>;
        }));
    }

    protected processWeatherAlertModifierAll(response: HttpResponseBase): Observable<WeatherAlertModifier[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherAlertModifier.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    weatherAlertModifierGET(id: number): Observable<WeatherAlertModifier> {
        let url_ = this.baseUrl + "/api/v1/WeatherAlertModifier/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherAlertModifierGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherAlertModifierGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherAlertModifier>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherAlertModifier>;
        }));
    }

    protected processWeatherAlertModifierGET(response: HttpResponseBase): Observable<WeatherAlertModifier> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeatherAlertModifier.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    weatherAlertModifierPUT(id: number, body: WeatherAlertModifier | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/WeatherAlertModifier/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherAlertModifierPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherAlertModifierPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWeatherAlertModifierPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    weatherAlertModifierDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/WeatherAlertModifier/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherAlertModifierDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherAlertModifierDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWeatherAlertModifierDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWeatherEventClient {
    /**
     * @param body (optional) 
     * @return Success
     */
    formGuide(body: WeatherEventFormGuideRequest | undefined): Observable<WeatherEventFormGuide>;
    /**
     * @param body (optional) 
     * @return Created
     */
    weatherEventPOST(body: WeatherEvent | undefined): Observable<WeatherEvent>;
    /**
     * @return Success
     */
    weatherEventAll(): Observable<WeatherEvent[]>;
    /**
     * @return Success
     */
    weatherEventGET(id: number): Observable<WeatherEvent>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    weatherEventPUT(id: number, body: WeatherEvent | undefined): Observable<void>;
    /**
     * @return No Content
     */
    weatherEventDELETE(id: number): Observable<void>;
}

@Injectable()
export class WeatherEventClient implements IWeatherEventClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    formGuide(body: WeatherEventFormGuideRequest | undefined): Observable<WeatherEventFormGuide> {
        let url_ = this.baseUrl + "/api/v1/WeatherEvent/FormGuide";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFormGuide(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFormGuide(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherEventFormGuide>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherEventFormGuide>;
        }));
    }

    protected processFormGuide(response: HttpResponseBase): Observable<WeatherEventFormGuide> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeatherEventFormGuide.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    weatherEventPOST(body: WeatherEvent | undefined): Observable<WeatherEvent> {
        let url_ = this.baseUrl + "/api/v1/WeatherEvent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherEventPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherEventPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherEvent>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherEvent>;
        }));
    }

    protected processWeatherEventPOST(response: HttpResponseBase): Observable<WeatherEvent> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = WeatherEvent.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    weatherEventAll(): Observable<WeatherEvent[]> {
        let url_ = this.baseUrl + "/api/v1/WeatherEvent";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherEventAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherEventAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherEvent[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherEvent[]>;
        }));
    }

    protected processWeatherEventAll(response: HttpResponseBase): Observable<WeatherEvent[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherEvent.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    weatherEventGET(id: number): Observable<WeatherEvent> {
        let url_ = this.baseUrl + "/api/v1/WeatherEvent/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherEventGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherEventGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherEvent>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherEvent>;
        }));
    }

    protected processWeatherEventGET(response: HttpResponseBase): Observable<WeatherEvent> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeatherEvent.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    weatherEventPUT(id: number, body: WeatherEvent | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/WeatherEvent/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherEventPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherEventPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWeatherEventPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    weatherEventDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/WeatherEvent/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherEventDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherEventDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWeatherEventDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWeatherExperienceClient {
    /**
     * @param body (optional) 
     * @return Created
     */
    weatherExperiencePOST(body: WeatherExperience | undefined): Observable<WeatherExperience>;
    /**
     * @return Success
     */
    weatherExperienceAll(): Observable<WeatherExperience[]>;
    /**
     * @return Success
     */
    weatherExperienceGET(id: number): Observable<WeatherExperience>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    weatherExperiencePUT(id: number, body: WeatherExperience | undefined): Observable<void>;
    /**
     * @return No Content
     */
    weatherExperienceDELETE(id: number): Observable<void>;
}

@Injectable()
export class WeatherExperienceClient implements IWeatherExperienceClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    weatherExperiencePOST(body: WeatherExperience | undefined): Observable<WeatherExperience> {
        let url_ = this.baseUrl + "/api/v1/WeatherExperience";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherExperiencePOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherExperiencePOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherExperience>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherExperience>;
        }));
    }

    protected processWeatherExperiencePOST(response: HttpResponseBase): Observable<WeatherExperience> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = WeatherExperience.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    weatherExperienceAll(): Observable<WeatherExperience[]> {
        let url_ = this.baseUrl + "/api/v1/WeatherExperience";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherExperienceAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherExperienceAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherExperience[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherExperience[]>;
        }));
    }

    protected processWeatherExperienceAll(response: HttpResponseBase): Observable<WeatherExperience[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherExperience.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    weatherExperienceGET(id: number): Observable<WeatherExperience> {
        let url_ = this.baseUrl + "/api/v1/WeatherExperience/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherExperienceGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherExperienceGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherExperience>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherExperience>;
        }));
    }

    protected processWeatherExperienceGET(response: HttpResponseBase): Observable<WeatherExperience> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WeatherExperience.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    weatherExperiencePUT(id: number, body: WeatherExperience | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/WeatherExperience/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherExperiencePUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherExperiencePUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWeatherExperiencePUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    weatherExperienceDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/WeatherExperience/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherExperienceDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherExperienceDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWeatherExperienceDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class ArrayFormControlValidation implements IArrayFormControlValidation {
    public minElements?: number;
    public maxElements?: number;

    constructor(data?: IArrayFormControlValidation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new ArrayFormControlValidation instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new ArrayFormControlValidation.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.minElements = _data["minElements"] !== undefined ? _data["minElements"] : <any>null;
            this.maxElements = _data["maxElements"] !== undefined ? _data["maxElements"] : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this ArrayFormControlValidation.
    * @param data Any object that holds the necessary properties to initialize a new ArrayFormControlValidation.
    * @returns A deserialized ArrayFormControlValidation.
    **/
    public static fromJS(data: any): ArrayFormControlValidation {
        data = typeof data === 'object' ? data : {};
        let result = new ArrayFormControlValidation();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this ArrayFormControlValidation.
    * @returns A serialized ArrayFormControlValidation.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minElements"] = this.minElements !== undefined ? this.minElements : <any>null;
        data["maxElements"] = this.maxElements !== undefined ? this.maxElements : <any>null;
        return data;
    }
}

export interface IArrayFormControlValidation {
    minElements?: number;
    maxElements?: number;
}

export class BooleanFormControl implements IBooleanFormControl {
    public validation!: FormControlValidation;
    public readOnly!: boolean;
    public hidden!: boolean;
    public defaultValue!: boolean;
    public suppliedValues!: BooleanFormControlValue[];

    constructor(data?: IBooleanFormControl) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.validation = data.validation && !(<any>data.validation).toJSON ? new FormControlValidation(data.validation) : <FormControlValidation>this.validation;
            if (data.suppliedValues) {
                this.suppliedValues = [];
                for (let i = 0; i < data.suppliedValues.length; i++) {
                    let item = data.suppliedValues[i];
                    this.suppliedValues[i] = item && !(<any>item).toJSON ? new BooleanFormControlValue(item) : <BooleanFormControlValue>item;
                }
            }
        }
        if (!data) {
            this.validation = new FormControlValidation();
            this.suppliedValues = [];
        }
    }

    /**
    * Initializes a new BooleanFormControl instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new BooleanFormControl.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.validation = _data["validation"] ? FormControlValidation.fromJS(_data["validation"]) : new FormControlValidation();
            this.readOnly = _data["readOnly"] !== undefined ? _data["readOnly"] : <any>null;
            this.hidden = _data["hidden"] !== undefined ? _data["hidden"] : <any>null;
            this.defaultValue = _data["defaultValue"] !== undefined ? _data["defaultValue"] : <any>null;
            if (Array.isArray(_data["suppliedValues"])) {
                this.suppliedValues = [] as any;
                for (let item of _data["suppliedValues"])
                    this.suppliedValues!.push(BooleanFormControlValue.fromJS(item));
            }
            else {
                this.suppliedValues = <any>null;
            }
        }
    }

    /**
    * Deserializes a JSON representation of this BooleanFormControl.
    * @param data Any object that holds the necessary properties to initialize a new BooleanFormControl.
    * @returns A deserialized BooleanFormControl.
    **/
    public static fromJS(data: any): BooleanFormControl {
        data = typeof data === 'object' ? data : {};
        let result = new BooleanFormControl();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this BooleanFormControl.
    * @returns A serialized BooleanFormControl.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["validation"] = this.validation ? this.validation.toJSON() : <any>null;
        data["readOnly"] = this.readOnly !== undefined ? this.readOnly : <any>null;
        data["hidden"] = this.hidden !== undefined ? this.hidden : <any>null;
        data["defaultValue"] = this.defaultValue !== undefined ? this.defaultValue : <any>null;
        if (Array.isArray(this.suppliedValues)) {
            data["suppliedValues"] = [];
            for (let item of this.suppliedValues)
                data["suppliedValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBooleanFormControl {
    validation: IFormControlValidation;
    readOnly: boolean;
    hidden: boolean;
    defaultValue: boolean;
    suppliedValues: IBooleanFormControlValue[];
}

export class BooleanFormControlValue implements IBooleanFormControlValue {
    public name!: string;
    public value!: boolean;

    constructor(data?: IBooleanFormControlValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new BooleanFormControlValue instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new BooleanFormControlValue.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this BooleanFormControlValue.
    * @param data Any object that holds the necessary properties to initialize a new BooleanFormControlValue.
    * @returns A deserialized BooleanFormControlValue.
    **/
    public static fromJS(data: any): BooleanFormControlValue {
        data = typeof data === 'object' ? data : {};
        let result = new BooleanFormControlValue();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this BooleanFormControlValue.
    * @returns A serialized BooleanFormControlValue.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IBooleanFormControlValue {
    name: string;
    value: boolean;
}

export class DateTimeOffsetFormControl implements IDateTimeOffsetFormControl {
    public validation!: FormControlValidation;
    public readOnly!: boolean;
    public hidden!: boolean;
    public defaultValue!: Date;
    public suppliedValues!: DateTimeOffsetFormControlValue[];

    constructor(data?: IDateTimeOffsetFormControl) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.validation = data.validation && !(<any>data.validation).toJSON ? new FormControlValidation(data.validation) : <FormControlValidation>this.validation;
            if (data.suppliedValues) {
                this.suppliedValues = [];
                for (let i = 0; i < data.suppliedValues.length; i++) {
                    let item = data.suppliedValues[i];
                    this.suppliedValues[i] = item && !(<any>item).toJSON ? new DateTimeOffsetFormControlValue(item) : <DateTimeOffsetFormControlValue>item;
                }
            }
        }
        if (!data) {
            this.validation = new FormControlValidation();
            this.suppliedValues = [];
        }
    }

    /**
    * Initializes a new DateTimeOffsetFormControl instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new DateTimeOffsetFormControl.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.validation = _data["validation"] ? FormControlValidation.fromJS(_data["validation"]) : new FormControlValidation();
            this.readOnly = _data["readOnly"] !== undefined ? _data["readOnly"] : <any>null;
            this.hidden = _data["hidden"] !== undefined ? _data["hidden"] : <any>null;
            this.defaultValue = _data["defaultValue"] ? new Date(_data["defaultValue"].toString()) : <any>null;
            if (Array.isArray(_data["suppliedValues"])) {
                this.suppliedValues = [] as any;
                for (let item of _data["suppliedValues"])
                    this.suppliedValues!.push(DateTimeOffsetFormControlValue.fromJS(item));
            }
            else {
                this.suppliedValues = <any>null;
            }
        }
    }

    /**
    * Deserializes a JSON representation of this DateTimeOffsetFormControl.
    * @param data Any object that holds the necessary properties to initialize a new DateTimeOffsetFormControl.
    * @returns A deserialized DateTimeOffsetFormControl.
    **/
    public static fromJS(data: any): DateTimeOffsetFormControl {
        data = typeof data === 'object' ? data : {};
        let result = new DateTimeOffsetFormControl();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this DateTimeOffsetFormControl.
    * @returns A serialized DateTimeOffsetFormControl.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["validation"] = this.validation ? this.validation.toJSON() : <any>null;
        data["readOnly"] = this.readOnly !== undefined ? this.readOnly : <any>null;
        data["hidden"] = this.hidden !== undefined ? this.hidden : <any>null;
        data["defaultValue"] = this.defaultValue ? this.defaultValue.toISOString() : <any>null;
        if (Array.isArray(this.suppliedValues)) {
            data["suppliedValues"] = [];
            for (let item of this.suppliedValues)
                data["suppliedValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDateTimeOffsetFormControl {
    validation: IFormControlValidation;
    readOnly: boolean;
    hidden: boolean;
    defaultValue: Date;
    suppliedValues: IDateTimeOffsetFormControlValue[];
}

export class DateTimeOffsetFormControlValidation implements IDateTimeOffsetFormControlValidation {
    public minValue?: Date;
    public maxValue?: Date;

    constructor(data?: IDateTimeOffsetFormControlValidation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new DateTimeOffsetFormControlValidation instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new DateTimeOffsetFormControlValidation.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.minValue = _data["minValue"] ? new Date(_data["minValue"].toString()) : <any>null;
            this.maxValue = _data["maxValue"] ? new Date(_data["maxValue"].toString()) : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this DateTimeOffsetFormControlValidation.
    * @param data Any object that holds the necessary properties to initialize a new DateTimeOffsetFormControlValidation.
    * @returns A deserialized DateTimeOffsetFormControlValidation.
    **/
    public static fromJS(data: any): DateTimeOffsetFormControlValidation {
        data = typeof data === 'object' ? data : {};
        let result = new DateTimeOffsetFormControlValidation();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this DateTimeOffsetFormControlValidation.
    * @returns A serialized DateTimeOffsetFormControlValidation.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minValue"] = this.minValue ? this.minValue.toISOString() : <any>null;
        data["maxValue"] = this.maxValue ? this.maxValue.toISOString() : <any>null;
        return data;
    }
}

export interface IDateTimeOffsetFormControlValidation {
    minValue?: Date;
    maxValue?: Date;
}

export class DateTimeOffsetFormControlValue implements IDateTimeOffsetFormControlValue {
    public name!: string;
    public value!: Date;

    constructor(data?: IDateTimeOffsetFormControlValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new DateTimeOffsetFormControlValue instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new DateTimeOffsetFormControlValue.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.value = _data["value"] ? new Date(_data["value"].toString()) : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this DateTimeOffsetFormControlValue.
    * @param data Any object that holds the necessary properties to initialize a new DateTimeOffsetFormControlValue.
    * @returns A deserialized DateTimeOffsetFormControlValue.
    **/
    public static fromJS(data: any): DateTimeOffsetFormControlValue {
        data = typeof data === 'object' ? data : {};
        let result = new DateTimeOffsetFormControlValue();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this DateTimeOffsetFormControlValue.
    * @returns A serialized DateTimeOffsetFormControlValue.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["value"] = this.value ? this.value.toISOString() : <any>null;
        return data;
    }
}

export interface IDateTimeOffsetFormControlValue {
    name: string;
    value: Date;
}

export class FormControlValidation implements IFormControlValidation {
    public required?: boolean;
    public pattern?: string | null;
    public stringValidation?: StringFormControlValidation;
    public numericValidation?: NumericFormControlValidation;
    public dateTimeValidation?: DateTimeOffsetFormControlValidation;
    public arrayValidation?: ArrayFormControlValidation;

    constructor(data?: IFormControlValidation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.stringValidation = data.stringValidation && !(<any>data.stringValidation).toJSON ? new StringFormControlValidation(data.stringValidation) : <StringFormControlValidation>this.stringValidation;
            this.numericValidation = data.numericValidation && !(<any>data.numericValidation).toJSON ? new NumericFormControlValidation(data.numericValidation) : <NumericFormControlValidation>this.numericValidation;
            this.dateTimeValidation = data.dateTimeValidation && !(<any>data.dateTimeValidation).toJSON ? new DateTimeOffsetFormControlValidation(data.dateTimeValidation) : <DateTimeOffsetFormControlValidation>this.dateTimeValidation;
            this.arrayValidation = data.arrayValidation && !(<any>data.arrayValidation).toJSON ? new ArrayFormControlValidation(data.arrayValidation) : <ArrayFormControlValidation>this.arrayValidation;
        }
    }

    /**
    * Initializes a new FormControlValidation instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new FormControlValidation.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.required = _data["required"] !== undefined ? _data["required"] : <any>null;
            this.pattern = _data["pattern"] !== undefined ? _data["pattern"] : <any>null;
            this.stringValidation = _data["stringValidation"] ? StringFormControlValidation.fromJS(_data["stringValidation"]) : <any>null;
            this.numericValidation = _data["numericValidation"] ? NumericFormControlValidation.fromJS(_data["numericValidation"]) : <any>null;
            this.dateTimeValidation = _data["dateTimeValidation"] ? DateTimeOffsetFormControlValidation.fromJS(_data["dateTimeValidation"]) : <any>null;
            this.arrayValidation = _data["arrayValidation"] ? ArrayFormControlValidation.fromJS(_data["arrayValidation"]) : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this FormControlValidation.
    * @param data Any object that holds the necessary properties to initialize a new FormControlValidation.
    * @returns A deserialized FormControlValidation.
    **/
    public static fromJS(data: any): FormControlValidation {
        data = typeof data === 'object' ? data : {};
        let result = new FormControlValidation();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this FormControlValidation.
    * @returns A serialized FormControlValidation.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["required"] = this.required !== undefined ? this.required : <any>null;
        data["pattern"] = this.pattern !== undefined ? this.pattern : <any>null;
        data["stringValidation"] = this.stringValidation ? this.stringValidation.toJSON() : <any>null;
        data["numericValidation"] = this.numericValidation ? this.numericValidation.toJSON() : <any>null;
        data["dateTimeValidation"] = this.dateTimeValidation ? this.dateTimeValidation.toJSON() : <any>null;
        data["arrayValidation"] = this.arrayValidation ? this.arrayValidation.toJSON() : <any>null;
        return data;
    }
}

export interface IFormControlValidation {
    required?: boolean;
    pattern?: string | null;
    stringValidation?: IStringFormControlValidation;
    numericValidation?: INumericFormControlValidation;
    dateTimeValidation?: IDateTimeOffsetFormControlValidation;
    arrayValidation?: IArrayFormControlValidation;
}

export class FormGuideContext implements IFormGuideContext {
    public attributes!: { [key: string]: any; };

    constructor(data?: IFormGuideContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.attributes = {};
        }
    }

    /**
    * Initializes a new FormGuideContext instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new FormGuideContext.
    **/
    protected init(_data?: any) {
        if (_data) {
            if (_data["attributes"]) {
                this.attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>this.attributes)![key] = _data["attributes"][key] !== undefined ? _data["attributes"][key] : <any>null;
                }
            }
            else {
                this.attributes = <any>null;
            }
        }
    }

    /**
    * Deserializes a JSON representation of this FormGuideContext.
    * @param data Any object that holds the necessary properties to initialize a new FormGuideContext.
    * @returns A deserialized FormGuideContext.
    **/
    public static fromJS(data: any): FormGuideContext {
        data = typeof data === 'object' ? data : {};
        let result = new FormGuideContext();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this FormGuideContext.
    * @returns A serialized FormGuideContext.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    (<any>data["attributes"])[key] = this.attributes[key] !== undefined ? this.attributes[key] : <any>null;
            }
        }
        return data;
    }
}

export interface IFormGuideContext {
    attributes: { [key: string]: any; };
}

export class Int32FormControl implements IInt32FormControl {
    public validation!: FormControlValidation;
    public readOnly!: boolean;
    public hidden!: boolean;
    public defaultValue!: number;
    public suppliedValues!: Int32FormControlValue[];

    constructor(data?: IInt32FormControl) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.validation = data.validation && !(<any>data.validation).toJSON ? new FormControlValidation(data.validation) : <FormControlValidation>this.validation;
            if (data.suppliedValues) {
                this.suppliedValues = [];
                for (let i = 0; i < data.suppliedValues.length; i++) {
                    let item = data.suppliedValues[i];
                    this.suppliedValues[i] = item && !(<any>item).toJSON ? new Int32FormControlValue(item) : <Int32FormControlValue>item;
                }
            }
        }
        if (!data) {
            this.validation = new FormControlValidation();
            this.suppliedValues = [];
        }
    }

    /**
    * Initializes a new Int32FormControl instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new Int32FormControl.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.validation = _data["validation"] ? FormControlValidation.fromJS(_data["validation"]) : new FormControlValidation();
            this.readOnly = _data["readOnly"] !== undefined ? _data["readOnly"] : <any>null;
            this.hidden = _data["hidden"] !== undefined ? _data["hidden"] : <any>null;
            this.defaultValue = _data["defaultValue"] !== undefined ? _data["defaultValue"] : <any>null;
            if (Array.isArray(_data["suppliedValues"])) {
                this.suppliedValues = [] as any;
                for (let item of _data["suppliedValues"])
                    this.suppliedValues!.push(Int32FormControlValue.fromJS(item));
            }
            else {
                this.suppliedValues = <any>null;
            }
        }
    }

    /**
    * Deserializes a JSON representation of this Int32FormControl.
    * @param data Any object that holds the necessary properties to initialize a new Int32FormControl.
    * @returns A deserialized Int32FormControl.
    **/
    public static fromJS(data: any): Int32FormControl {
        data = typeof data === 'object' ? data : {};
        let result = new Int32FormControl();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this Int32FormControl.
    * @returns A serialized Int32FormControl.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["validation"] = this.validation ? this.validation.toJSON() : <any>null;
        data["readOnly"] = this.readOnly !== undefined ? this.readOnly : <any>null;
        data["hidden"] = this.hidden !== undefined ? this.hidden : <any>null;
        data["defaultValue"] = this.defaultValue !== undefined ? this.defaultValue : <any>null;
        if (Array.isArray(this.suppliedValues)) {
            data["suppliedValues"] = [];
            for (let item of this.suppliedValues)
                data["suppliedValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInt32FormControl {
    validation: IFormControlValidation;
    readOnly: boolean;
    hidden: boolean;
    defaultValue: number;
    suppliedValues: IInt32FormControlValue[];
}

export class Int32FormControlValue implements IInt32FormControlValue {
    public name!: string;
    public value!: number;

    constructor(data?: IInt32FormControlValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new Int32FormControlValue instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new Int32FormControlValue.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this Int32FormControlValue.
    * @param data Any object that holds the necessary properties to initialize a new Int32FormControlValue.
    * @returns A deserialized Int32FormControlValue.
    **/
    public static fromJS(data: any): Int32FormControlValue {
        data = typeof data === 'object' ? data : {};
        let result = new Int32FormControlValue();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this Int32FormControlValue.
    * @returns A serialized Int32FormControlValue.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IInt32FormControlValue {
    name: string;
    value: number;
}

export class Location implements ILocation {
    public id?: number | null;
    public deleted!: boolean;
    public city!: string;
    public zipCode!: string;
    public country!: string;

    constructor(data?: ILocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new Location instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new Location.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
            this.city = _data["city"] !== undefined ? _data["city"] : <any>null;
            this.zipCode = _data["zipCode"] !== undefined ? _data["zipCode"] : <any>null;
            this.country = _data["country"] !== undefined ? _data["country"] : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this Location.
    * @param data Any object that holds the necessary properties to initialize a new Location.
    * @returns A deserialized Location.
    **/
    public static fromJS(data: any): Location {
        data = typeof data === 'object' ? data : {};
        let result = new Location();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this Location.
    * @returns A serialized Location.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["city"] = this.city !== undefined ? this.city : <any>null;
        data["zipCode"] = this.zipCode !== undefined ? this.zipCode : <any>null;
        data["country"] = this.country !== undefined ? this.country : <any>null;
        return data;
    }
}

export interface ILocation {
    id?: number | null;
    deleted: boolean;
    city: string;
    zipCode: string;
    country: string;
}

export class LocationFormGuide implements ILocationFormGuide {

    constructor(data?: ILocationFormGuide) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new LocationFormGuide instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new LocationFormGuide.
    **/
    protected init(_data?: any) {
    }

    /**
    * Deserializes a JSON representation of this LocationFormGuide.
    * @param data Any object that holds the necessary properties to initialize a new LocationFormGuide.
    * @returns A deserialized LocationFormGuide.
    **/
    public static fromJS(data: any): LocationFormGuide {
        data = typeof data === 'object' ? data : {};
        let result = new LocationFormGuide();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this LocationFormGuide.
    * @returns A serialized LocationFormGuide.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface ILocationFormGuide {
}

export class NumericFormControlValidation implements INumericFormControlValidation {
    public minValue?: number;
    public maxValue?: number;

    constructor(data?: INumericFormControlValidation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new NumericFormControlValidation instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new NumericFormControlValidation.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.minValue = _data["minValue"] !== undefined ? _data["minValue"] : <any>null;
            this.maxValue = _data["maxValue"] !== undefined ? _data["maxValue"] : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this NumericFormControlValidation.
    * @param data Any object that holds the necessary properties to initialize a new NumericFormControlValidation.
    * @returns A deserialized NumericFormControlValidation.
    **/
    public static fromJS(data: any): NumericFormControlValidation {
        data = typeof data === 'object' ? data : {};
        let result = new NumericFormControlValidation();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this NumericFormControlValidation.
    * @returns A serialized NumericFormControlValidation.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minValue"] = this.minValue !== undefined ? this.minValue : <any>null;
        data["maxValue"] = this.maxValue !== undefined ? this.maxValue : <any>null;
        return data;
    }
}

export interface INumericFormControlValidation {
    minValue?: number;
    maxValue?: number;
}

export class ProblemDetails implements IProblemDetails {
    public type?: string | null;
    public title?: string | null;
    public status?: number | null;
    public detail?: string | null;
    public instance?: string | null;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new ProblemDetails instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new ProblemDetails.
    **/
    protected init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.detail = _data["detail"] !== undefined ? _data["detail"] : <any>null;
            this.instance = _data["instance"] !== undefined ? _data["instance"] : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this ProblemDetails.
    * @param data Any object that holds the necessary properties to initialize a new ProblemDetails.
    * @returns A deserialized ProblemDetails.
    **/
    public static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this ProblemDetails.
    * @returns A serialized ProblemDetails.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["detail"] = this.detail !== undefined ? this.detail : <any>null;
        data["instance"] = this.instance !== undefined ? this.instance : <any>null;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;

    [key: string]: any;
}

export class SingleFormControl implements ISingleFormControl {
    public validation!: FormControlValidation;
    public readOnly!: boolean;
    public hidden!: boolean;
    public defaultValue!: number;
    public suppliedValues!: SingleFormControlValue[];

    constructor(data?: ISingleFormControl) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.validation = data.validation && !(<any>data.validation).toJSON ? new FormControlValidation(data.validation) : <FormControlValidation>this.validation;
            if (data.suppliedValues) {
                this.suppliedValues = [];
                for (let i = 0; i < data.suppliedValues.length; i++) {
                    let item = data.suppliedValues[i];
                    this.suppliedValues[i] = item && !(<any>item).toJSON ? new SingleFormControlValue(item) : <SingleFormControlValue>item;
                }
            }
        }
        if (!data) {
            this.validation = new FormControlValidation();
            this.suppliedValues = [];
        }
    }

    /**
    * Initializes a new SingleFormControl instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new SingleFormControl.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.validation = _data["validation"] ? FormControlValidation.fromJS(_data["validation"]) : new FormControlValidation();
            this.readOnly = _data["readOnly"] !== undefined ? _data["readOnly"] : <any>null;
            this.hidden = _data["hidden"] !== undefined ? _data["hidden"] : <any>null;
            this.defaultValue = _data["defaultValue"] !== undefined ? _data["defaultValue"] : <any>null;
            if (Array.isArray(_data["suppliedValues"])) {
                this.suppliedValues = [] as any;
                for (let item of _data["suppliedValues"])
                    this.suppliedValues!.push(SingleFormControlValue.fromJS(item));
            }
            else {
                this.suppliedValues = <any>null;
            }
        }
    }

    /**
    * Deserializes a JSON representation of this SingleFormControl.
    * @param data Any object that holds the necessary properties to initialize a new SingleFormControl.
    * @returns A deserialized SingleFormControl.
    **/
    public static fromJS(data: any): SingleFormControl {
        data = typeof data === 'object' ? data : {};
        let result = new SingleFormControl();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this SingleFormControl.
    * @returns A serialized SingleFormControl.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["validation"] = this.validation ? this.validation.toJSON() : <any>null;
        data["readOnly"] = this.readOnly !== undefined ? this.readOnly : <any>null;
        data["hidden"] = this.hidden !== undefined ? this.hidden : <any>null;
        data["defaultValue"] = this.defaultValue !== undefined ? this.defaultValue : <any>null;
        if (Array.isArray(this.suppliedValues)) {
            data["suppliedValues"] = [];
            for (let item of this.suppliedValues)
                data["suppliedValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISingleFormControl {
    validation: IFormControlValidation;
    readOnly: boolean;
    hidden: boolean;
    defaultValue: number;
    suppliedValues: ISingleFormControlValue[];
}

export class SingleFormControlValue implements ISingleFormControlValue {
    public name!: string;
    public value!: number;

    constructor(data?: ISingleFormControlValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new SingleFormControlValue instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new SingleFormControlValue.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this SingleFormControlValue.
    * @param data Any object that holds the necessary properties to initialize a new SingleFormControlValue.
    * @returns A deserialized SingleFormControlValue.
    **/
    public static fromJS(data: any): SingleFormControlValue {
        data = typeof data === 'object' ? data : {};
        let result = new SingleFormControlValue();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this SingleFormControlValue.
    * @returns A serialized SingleFormControlValue.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface ISingleFormControlValue {
    name: string;
    value: number;
}

export class StringFormControl implements IStringFormControl {
    public validation!: FormControlValidation;
    public readOnly!: boolean;
    public hidden!: boolean;
    public defaultValue!: string;
    public suppliedValues!: StringFormControlValue[];

    constructor(data?: IStringFormControl) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.validation = data.validation && !(<any>data.validation).toJSON ? new FormControlValidation(data.validation) : <FormControlValidation>this.validation;
            if (data.suppliedValues) {
                this.suppliedValues = [];
                for (let i = 0; i < data.suppliedValues.length; i++) {
                    let item = data.suppliedValues[i];
                    this.suppliedValues[i] = item && !(<any>item).toJSON ? new StringFormControlValue(item) : <StringFormControlValue>item;
                }
            }
        }
        if (!data) {
            this.validation = new FormControlValidation();
            this.suppliedValues = [];
        }
    }

    /**
    * Initializes a new StringFormControl instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new StringFormControl.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.validation = _data["validation"] ? FormControlValidation.fromJS(_data["validation"]) : new FormControlValidation();
            this.readOnly = _data["readOnly"] !== undefined ? _data["readOnly"] : <any>null;
            this.hidden = _data["hidden"] !== undefined ? _data["hidden"] : <any>null;
            this.defaultValue = _data["defaultValue"] !== undefined ? _data["defaultValue"] : <any>null;
            if (Array.isArray(_data["suppliedValues"])) {
                this.suppliedValues = [] as any;
                for (let item of _data["suppliedValues"])
                    this.suppliedValues!.push(StringFormControlValue.fromJS(item));
            }
            else {
                this.suppliedValues = <any>null;
            }
        }
    }

    /**
    * Deserializes a JSON representation of this StringFormControl.
    * @param data Any object that holds the necessary properties to initialize a new StringFormControl.
    * @returns A deserialized StringFormControl.
    **/
    public static fromJS(data: any): StringFormControl {
        data = typeof data === 'object' ? data : {};
        let result = new StringFormControl();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this StringFormControl.
    * @returns A serialized StringFormControl.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["validation"] = this.validation ? this.validation.toJSON() : <any>null;
        data["readOnly"] = this.readOnly !== undefined ? this.readOnly : <any>null;
        data["hidden"] = this.hidden !== undefined ? this.hidden : <any>null;
        data["defaultValue"] = this.defaultValue !== undefined ? this.defaultValue : <any>null;
        if (Array.isArray(this.suppliedValues)) {
            data["suppliedValues"] = [];
            for (let item of this.suppliedValues)
                data["suppliedValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStringFormControl {
    validation: IFormControlValidation;
    readOnly: boolean;
    hidden: boolean;
    defaultValue: string;
    suppliedValues: IStringFormControlValue[];
}

export class StringFormControlValidation implements IStringFormControlValidation {
    public minLength?: number;
    public maxLength?: number;

    constructor(data?: IStringFormControlValidation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new StringFormControlValidation instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new StringFormControlValidation.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.minLength = _data["minLength"] !== undefined ? _data["minLength"] : <any>null;
            this.maxLength = _data["maxLength"] !== undefined ? _data["maxLength"] : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this StringFormControlValidation.
    * @param data Any object that holds the necessary properties to initialize a new StringFormControlValidation.
    * @returns A deserialized StringFormControlValidation.
    **/
    public static fromJS(data: any): StringFormControlValidation {
        data = typeof data === 'object' ? data : {};
        let result = new StringFormControlValidation();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this StringFormControlValidation.
    * @returns A serialized StringFormControlValidation.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minLength"] = this.minLength !== undefined ? this.minLength : <any>null;
        data["maxLength"] = this.maxLength !== undefined ? this.maxLength : <any>null;
        return data;
    }
}

export interface IStringFormControlValidation {
    minLength?: number;
    maxLength?: number;
}

export class StringFormControlValue implements IStringFormControlValue {
    public name!: string;
    public value!: string;

    constructor(data?: IStringFormControlValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new StringFormControlValue instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new StringFormControlValue.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this StringFormControlValue.
    * @param data Any object that holds the necessary properties to initialize a new StringFormControlValue.
    * @returns A deserialized StringFormControlValue.
    **/
    public static fromJS(data: any): StringFormControlValue {
        data = typeof data === 'object' ? data : {};
        let result = new StringFormControlValue();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this StringFormControlValue.
    * @returns A serialized StringFormControlValue.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IStringFormControlValue {
    name: string;
    value: string;
}

export class Weather implements IWeather {
    public id?: number | null;
    public deleted!: boolean;
    public name!: string;
    public description!: string;

    constructor(data?: IWeather) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new Weather instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new Weather.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this Weather.
    * @param data Any object that holds the necessary properties to initialize a new Weather.
    * @returns A deserialized Weather.
    **/
    public static fromJS(data: any): Weather {
        data = typeof data === 'object' ? data : {};
        let result = new Weather();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this Weather.
    * @returns A serialized Weather.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export interface IWeather {
    id?: number | null;
    deleted: boolean;
    name: string;
    description: string;
}

export class WeatherAlert implements IWeatherAlert {
    public id?: number | null;
    public deleted!: boolean;
    public name!: string;
    public description!: string;
    public value!: number;
    public isThirdParty!: boolean;

    constructor(data?: IWeatherAlert) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new WeatherAlert instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherAlert.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
            this.isThirdParty = _data["isThirdParty"] !== undefined ? _data["isThirdParty"] : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherAlert.
    * @param data Any object that holds the necessary properties to initialize a new WeatherAlert.
    * @returns A deserialized WeatherAlert.
    **/
    public static fromJS(data: any): WeatherAlert {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherAlert();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherAlert.
    * @returns A serialized WeatherAlert.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        data["isThirdParty"] = this.isThirdParty !== undefined ? this.isThirdParty : <any>null;
        return data;
    }
}

export interface IWeatherAlert {
    id?: number | null;
    deleted: boolean;
    name: string;
    description: string;
    value: number;
    isThirdParty: boolean;
}

export class WeatherAlertFormControl implements IWeatherAlertFormControl {
    public validation!: FormControlValidation;
    public readOnly!: boolean;
    public hidden!: boolean;
    public defaultValue!: WeatherAlert;
    public suppliedValues!: WeatherAlertFormControlValue[];

    constructor(data?: IWeatherAlertFormControl) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.validation = data.validation && !(<any>data.validation).toJSON ? new FormControlValidation(data.validation) : <FormControlValidation>this.validation;
            this.defaultValue = data.defaultValue && !(<any>data.defaultValue).toJSON ? new WeatherAlert(data.defaultValue) : <WeatherAlert>this.defaultValue;
            if (data.suppliedValues) {
                this.suppliedValues = [];
                for (let i = 0; i < data.suppliedValues.length; i++) {
                    let item = data.suppliedValues[i];
                    this.suppliedValues[i] = item && !(<any>item).toJSON ? new WeatherAlertFormControlValue(item) : <WeatherAlertFormControlValue>item;
                }
            }
        }
        if (!data) {
            this.validation = new FormControlValidation();
            this.defaultValue = new WeatherAlert();
            this.suppliedValues = [];
        }
    }

    /**
    * Initializes a new WeatherAlertFormControl instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherAlertFormControl.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.validation = _data["validation"] ? FormControlValidation.fromJS(_data["validation"]) : new FormControlValidation();
            this.readOnly = _data["readOnly"] !== undefined ? _data["readOnly"] : <any>null;
            this.hidden = _data["hidden"] !== undefined ? _data["hidden"] : <any>null;
            this.defaultValue = _data["defaultValue"] ? WeatherAlert.fromJS(_data["defaultValue"]) : new WeatherAlert();
            if (Array.isArray(_data["suppliedValues"])) {
                this.suppliedValues = [] as any;
                for (let item of _data["suppliedValues"])
                    this.suppliedValues!.push(WeatherAlertFormControlValue.fromJS(item));
            }
            else {
                this.suppliedValues = <any>null;
            }
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherAlertFormControl.
    * @param data Any object that holds the necessary properties to initialize a new WeatherAlertFormControl.
    * @returns A deserialized WeatherAlertFormControl.
    **/
    public static fromJS(data: any): WeatherAlertFormControl {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherAlertFormControl();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherAlertFormControl.
    * @returns A serialized WeatherAlertFormControl.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["validation"] = this.validation ? this.validation.toJSON() : <any>null;
        data["readOnly"] = this.readOnly !== undefined ? this.readOnly : <any>null;
        data["hidden"] = this.hidden !== undefined ? this.hidden : <any>null;
        data["defaultValue"] = this.defaultValue ? this.defaultValue.toJSON() : <any>null;
        if (Array.isArray(this.suppliedValues)) {
            data["suppliedValues"] = [];
            for (let item of this.suppliedValues)
                data["suppliedValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWeatherAlertFormControl {
    validation: IFormControlValidation;
    readOnly: boolean;
    hidden: boolean;
    defaultValue: IWeatherAlert;
    suppliedValues: IWeatherAlertFormControlValue[];
}

export class WeatherAlertFormControlValue implements IWeatherAlertFormControlValue {
    public name!: string;
    public value!: WeatherAlert;

    constructor(data?: IWeatherAlertFormControlValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.value = data.value && !(<any>data.value).toJSON ? new WeatherAlert(data.value) : <WeatherAlert>this.value;
        }
        if (!data) {
            this.value = new WeatherAlert();
        }
    }

    /**
    * Initializes a new WeatherAlertFormControlValue instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherAlertFormControlValue.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.value = _data["value"] ? WeatherAlert.fromJS(_data["value"]) : new WeatherAlert();
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherAlertFormControlValue.
    * @param data Any object that holds the necessary properties to initialize a new WeatherAlertFormControlValue.
    * @returns A deserialized WeatherAlertFormControlValue.
    **/
    public static fromJS(data: any): WeatherAlertFormControlValue {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherAlertFormControlValue();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherAlertFormControlValue.
    * @returns A serialized WeatherAlertFormControlValue.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["value"] = this.value ? this.value.toJSON() : <any>null;
        return data;
    }
}

export interface IWeatherAlertFormControlValue {
    name: string;
    value: IWeatherAlert;
}

export class WeatherAlertModifier implements IWeatherAlertModifier {
    public id?: number | null;
    public deleted!: boolean;
    public name!: string;
    public description!: string;
    public bonus!: number;
    public operation!: WeatherAlertModifierOperation;

    constructor(data?: IWeatherAlertModifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new WeatherAlertModifier instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherAlertModifier.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.bonus = _data["bonus"] !== undefined ? _data["bonus"] : <any>null;
            this.operation = _data["operation"] !== undefined ? _data["operation"] : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherAlertModifier.
    * @param data Any object that holds the necessary properties to initialize a new WeatherAlertModifier.
    * @returns A deserialized WeatherAlertModifier.
    **/
    public static fromJS(data: any): WeatherAlertModifier {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherAlertModifier();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherAlertModifier.
    * @returns A serialized WeatherAlertModifier.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["bonus"] = this.bonus !== undefined ? this.bonus : <any>null;
        data["operation"] = this.operation !== undefined ? this.operation : <any>null;
        return data;
    }
}

export interface IWeatherAlertModifier {
    id?: number | null;
    deleted: boolean;
    name: string;
    description: string;
    bonus: number;
    operation: WeatherAlertModifierOperation;
}

export class WeatherAlertModifierFormControl implements IWeatherAlertModifierFormControl {
    public validation!: FormControlValidation;
    public readOnly!: boolean;
    public hidden!: boolean;
    public defaultValue!: WeatherAlertModifier;
    public suppliedValues!: WeatherAlertModifierFormControlValue[];

    constructor(data?: IWeatherAlertModifierFormControl) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.validation = data.validation && !(<any>data.validation).toJSON ? new FormControlValidation(data.validation) : <FormControlValidation>this.validation;
            this.defaultValue = data.defaultValue && !(<any>data.defaultValue).toJSON ? new WeatherAlertModifier(data.defaultValue) : <WeatherAlertModifier>this.defaultValue;
            if (data.suppliedValues) {
                this.suppliedValues = [];
                for (let i = 0; i < data.suppliedValues.length; i++) {
                    let item = data.suppliedValues[i];
                    this.suppliedValues[i] = item && !(<any>item).toJSON ? new WeatherAlertModifierFormControlValue(item) : <WeatherAlertModifierFormControlValue>item;
                }
            }
        }
        if (!data) {
            this.validation = new FormControlValidation();
            this.defaultValue = new WeatherAlertModifier();
            this.suppliedValues = [];
        }
    }

    /**
    * Initializes a new WeatherAlertModifierFormControl instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherAlertModifierFormControl.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.validation = _data["validation"] ? FormControlValidation.fromJS(_data["validation"]) : new FormControlValidation();
            this.readOnly = _data["readOnly"] !== undefined ? _data["readOnly"] : <any>null;
            this.hidden = _data["hidden"] !== undefined ? _data["hidden"] : <any>null;
            this.defaultValue = _data["defaultValue"] ? WeatherAlertModifier.fromJS(_data["defaultValue"]) : new WeatherAlertModifier();
            if (Array.isArray(_data["suppliedValues"])) {
                this.suppliedValues = [] as any;
                for (let item of _data["suppliedValues"])
                    this.suppliedValues!.push(WeatherAlertModifierFormControlValue.fromJS(item));
            }
            else {
                this.suppliedValues = <any>null;
            }
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherAlertModifierFormControl.
    * @param data Any object that holds the necessary properties to initialize a new WeatherAlertModifierFormControl.
    * @returns A deserialized WeatherAlertModifierFormControl.
    **/
    public static fromJS(data: any): WeatherAlertModifierFormControl {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherAlertModifierFormControl();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherAlertModifierFormControl.
    * @returns A serialized WeatherAlertModifierFormControl.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["validation"] = this.validation ? this.validation.toJSON() : <any>null;
        data["readOnly"] = this.readOnly !== undefined ? this.readOnly : <any>null;
        data["hidden"] = this.hidden !== undefined ? this.hidden : <any>null;
        data["defaultValue"] = this.defaultValue ? this.defaultValue.toJSON() : <any>null;
        if (Array.isArray(this.suppliedValues)) {
            data["suppliedValues"] = [];
            for (let item of this.suppliedValues)
                data["suppliedValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWeatherAlertModifierFormControl {
    validation: IFormControlValidation;
    readOnly: boolean;
    hidden: boolean;
    defaultValue: IWeatherAlertModifier;
    suppliedValues: IWeatherAlertModifierFormControlValue[];
}

export class WeatherAlertModifierFormControlValue implements IWeatherAlertModifierFormControlValue {
    public name!: string;
    public value!: WeatherAlertModifier;

    constructor(data?: IWeatherAlertModifierFormControlValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.value = data.value && !(<any>data.value).toJSON ? new WeatherAlertModifier(data.value) : <WeatherAlertModifier>this.value;
        }
        if (!data) {
            this.value = new WeatherAlertModifier();
        }
    }

    /**
    * Initializes a new WeatherAlertModifierFormControlValue instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherAlertModifierFormControlValue.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.value = _data["value"] ? WeatherAlertModifier.fromJS(_data["value"]) : new WeatherAlertModifier();
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherAlertModifierFormControlValue.
    * @param data Any object that holds the necessary properties to initialize a new WeatherAlertModifierFormControlValue.
    * @returns A deserialized WeatherAlertModifierFormControlValue.
    **/
    public static fromJS(data: any): WeatherAlertModifierFormControlValue {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherAlertModifierFormControlValue();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherAlertModifierFormControlValue.
    * @returns A serialized WeatherAlertModifierFormControlValue.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["value"] = this.value ? this.value.toJSON() : <any>null;
        return data;
    }
}

export interface IWeatherAlertModifierFormControlValue {
    name: string;
    value: IWeatherAlertModifier;
}

export enum WeatherAlertModifierOperation {
    Add = "Add",
    Multiply = "Multiply",
    Set = "Set",
}

export class WeatherEvent implements IWeatherEvent {
    public id?: number | null;
    public deleted!: boolean;
    public name!: string;
    public startDate!: Date;
    public weather!: Weather;
    public experience!: WeatherExperience;
    public statistics!: WeatherEventStatistics;
    public locations!: WeatherEventLocation[];
    public alerts!: WeatherEventAlert[];
    public description?: string | null;
    public endDate?: Date | null;

    constructor(data?: IWeatherEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.weather = data.weather && !(<any>data.weather).toJSON ? new Weather(data.weather) : <Weather>this.weather;
            this.experience = data.experience && !(<any>data.experience).toJSON ? new WeatherExperience(data.experience) : <WeatherExperience>this.experience;
            this.statistics = data.statistics && !(<any>data.statistics).toJSON ? new WeatherEventStatistics(data.statistics) : <WeatherEventStatistics>this.statistics;
            if (data.locations) {
                this.locations = [];
                for (let i = 0; i < data.locations.length; i++) {
                    let item = data.locations[i];
                    this.locations[i] = item && !(<any>item).toJSON ? new WeatherEventLocation(item) : <WeatherEventLocation>item;
                }
            }
            if (data.alerts) {
                this.alerts = [];
                for (let i = 0; i < data.alerts.length; i++) {
                    let item = data.alerts[i];
                    this.alerts[i] = item && !(<any>item).toJSON ? new WeatherEventAlert(item) : <WeatherEventAlert>item;
                }
            }
        }
        if (!data) {
            this.weather = new Weather();
            this.experience = new WeatherExperience();
            this.statistics = new WeatherEventStatistics();
            this.locations = [];
            this.alerts = [];
        }
    }

    /**
    * Initializes a new WeatherEvent instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherEvent.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>null;
            this.weather = _data["weather"] ? Weather.fromJS(_data["weather"]) : new Weather();
            this.experience = _data["experience"] ? WeatherExperience.fromJS(_data["experience"]) : new WeatherExperience();
            this.statistics = _data["statistics"] ? WeatherEventStatistics.fromJS(_data["statistics"]) : new WeatherEventStatistics();
            if (Array.isArray(_data["locations"])) {
                this.locations = [] as any;
                for (let item of _data["locations"])
                    this.locations!.push(WeatherEventLocation.fromJS(item));
            }
            else {
                this.locations = <any>null;
            }
            if (Array.isArray(_data["alerts"])) {
                this.alerts = [] as any;
                for (let item of _data["alerts"])
                    this.alerts!.push(WeatherEventAlert.fromJS(item));
            }
            else {
                this.alerts = <any>null;
            }
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherEvent.
    * @param data Any object that holds the necessary properties to initialize a new WeatherEvent.
    * @returns A deserialized WeatherEvent.
    **/
    public static fromJS(data: any): WeatherEvent {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherEvent();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherEvent.
    * @returns A serialized WeatherEvent.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>null;
        data["weather"] = this.weather ? this.weather.toJSON() : <any>null;
        data["experience"] = this.experience ? this.experience.toJSON() : <any>null;
        data["statistics"] = this.statistics ? this.statistics.toJSON() : <any>null;
        if (Array.isArray(this.locations)) {
            data["locations"] = [];
            for (let item of this.locations)
                data["locations"].push(item.toJSON());
        }
        if (Array.isArray(this.alerts)) {
            data["alerts"] = [];
            for (let item of this.alerts)
                data["alerts"].push(item.toJSON());
        }
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>null;
        return data;
    }
}

export interface IWeatherEvent {
    id?: number | null;
    deleted: boolean;
    name: string;
    startDate: Date;
    weather: IWeather;
    experience: IWeatherExperience;
    statistics: IWeatherEventStatistics;
    locations: IWeatherEventLocation[];
    alerts: IWeatherEventAlert[];
    description?: string | null;
    endDate?: Date | null;
}

export class WeatherEventAlert implements IWeatherEventAlert {
    public id?: number | null;
    public deleted!: boolean;
    public alert!: WeatherAlert;
    public issuanceTime!: Date;
    public modifiers!: WeatherEventAlertModifier[];

    constructor(data?: IWeatherEventAlert) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.alert = data.alert && !(<any>data.alert).toJSON ? new WeatherAlert(data.alert) : <WeatherAlert>this.alert;
            if (data.modifiers) {
                this.modifiers = [];
                for (let i = 0; i < data.modifiers.length; i++) {
                    let item = data.modifiers[i];
                    this.modifiers[i] = item && !(<any>item).toJSON ? new WeatherEventAlertModifier(item) : <WeatherEventAlertModifier>item;
                }
            }
        }
        if (!data) {
            this.alert = new WeatherAlert();
            this.modifiers = [];
        }
    }

    /**
    * Initializes a new WeatherEventAlert instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherEventAlert.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
            this.alert = _data["alert"] ? WeatherAlert.fromJS(_data["alert"]) : new WeatherAlert();
            this.issuanceTime = _data["issuanceTime"] ? new Date(_data["issuanceTime"].toString()) : <any>null;
            if (Array.isArray(_data["modifiers"])) {
                this.modifiers = [] as any;
                for (let item of _data["modifiers"])
                    this.modifiers!.push(WeatherEventAlertModifier.fromJS(item));
            }
            else {
                this.modifiers = <any>null;
            }
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherEventAlert.
    * @param data Any object that holds the necessary properties to initialize a new WeatherEventAlert.
    * @returns A deserialized WeatherEventAlert.
    **/
    public static fromJS(data: any): WeatherEventAlert {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherEventAlert();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherEventAlert.
    * @returns A serialized WeatherEventAlert.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["alert"] = this.alert ? this.alert.toJSON() : <any>null;
        data["issuanceTime"] = this.issuanceTime ? this.issuanceTime.toISOString() : <any>null;
        if (Array.isArray(this.modifiers)) {
            data["modifiers"] = [];
            for (let item of this.modifiers)
                data["modifiers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWeatherEventAlert {
    id?: number | null;
    deleted: boolean;
    alert: IWeatherAlert;
    issuanceTime: Date;
    modifiers: IWeatherEventAlertModifier[];
}

export class WeatherEventAlertFormGuide implements IWeatherEventAlertFormGuide {
    public alert!: WeatherAlertFormControl;
    public issuanceTime!: DateTimeOffsetFormControl;
    public modifiers!: WeatherAlertModifierFormControl[];

    constructor(data?: IWeatherEventAlertFormGuide) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.alert = data.alert && !(<any>data.alert).toJSON ? new WeatherAlertFormControl(data.alert) : <WeatherAlertFormControl>this.alert;
            this.issuanceTime = data.issuanceTime && !(<any>data.issuanceTime).toJSON ? new DateTimeOffsetFormControl(data.issuanceTime) : <DateTimeOffsetFormControl>this.issuanceTime;
            if (data.modifiers) {
                this.modifiers = [];
                for (let i = 0; i < data.modifiers.length; i++) {
                    let item = data.modifiers[i];
                    this.modifiers[i] = item && !(<any>item).toJSON ? new WeatherAlertModifierFormControl(item) : <WeatherAlertModifierFormControl>item;
                }
            }
        }
        if (!data) {
            this.alert = new WeatherAlertFormControl();
            this.issuanceTime = new DateTimeOffsetFormControl();
            this.modifiers = [];
        }
    }

    /**
    * Initializes a new WeatherEventAlertFormGuide instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherEventAlertFormGuide.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.alert = _data["alert"] ? WeatherAlertFormControl.fromJS(_data["alert"]) : new WeatherAlertFormControl();
            this.issuanceTime = _data["issuanceTime"] ? DateTimeOffsetFormControl.fromJS(_data["issuanceTime"]) : new DateTimeOffsetFormControl();
            if (Array.isArray(_data["modifiers"])) {
                this.modifiers = [] as any;
                for (let item of _data["modifiers"])
                    this.modifiers!.push(WeatherAlertModifierFormControl.fromJS(item));
            }
            else {
                this.modifiers = <any>null;
            }
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherEventAlertFormGuide.
    * @param data Any object that holds the necessary properties to initialize a new WeatherEventAlertFormGuide.
    * @returns A deserialized WeatherEventAlertFormGuide.
    **/
    public static fromJS(data: any): WeatherEventAlertFormGuide {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherEventAlertFormGuide();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherEventAlertFormGuide.
    * @returns A serialized WeatherEventAlertFormGuide.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alert"] = this.alert ? this.alert.toJSON() : <any>null;
        data["issuanceTime"] = this.issuanceTime ? this.issuanceTime.toJSON() : <any>null;
        if (Array.isArray(this.modifiers)) {
            data["modifiers"] = [];
            for (let item of this.modifiers)
                data["modifiers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWeatherEventAlertFormGuide {
    alert: IWeatherAlertFormControl;
    issuanceTime: IDateTimeOffsetFormControl;
    modifiers: IWeatherAlertModifierFormControl[];
}

export class WeatherEventAlertModifier implements IWeatherEventAlertModifier {
    public id?: number | null;
    public deleted!: boolean;
    public modifier!: WeatherAlertModifier;

    constructor(data?: IWeatherEventAlertModifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.modifier = data.modifier && !(<any>data.modifier).toJSON ? new WeatherAlertModifier(data.modifier) : <WeatherAlertModifier>this.modifier;
        }
        if (!data) {
            this.modifier = new WeatherAlertModifier();
        }
    }

    /**
    * Initializes a new WeatherEventAlertModifier instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherEventAlertModifier.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
            this.modifier = _data["modifier"] ? WeatherAlertModifier.fromJS(_data["modifier"]) : new WeatherAlertModifier();
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherEventAlertModifier.
    * @param data Any object that holds the necessary properties to initialize a new WeatherEventAlertModifier.
    * @returns A deserialized WeatherEventAlertModifier.
    **/
    public static fromJS(data: any): WeatherEventAlertModifier {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherEventAlertModifier();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherEventAlertModifier.
    * @returns A serialized WeatherEventAlertModifier.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["modifier"] = this.modifier ? this.modifier.toJSON() : <any>null;
        return data;
    }
}

export interface IWeatherEventAlertModifier {
    id?: number | null;
    deleted: boolean;
    modifier: IWeatherAlertModifier;
}

export class WeatherEventFormGuide implements IWeatherEventFormGuide {
    public name!: StringFormControl;
    public experience!: WeatherExperienceFormControl;
    public weather!: WeatherFormControl;
    public startDate!: DateTimeOffsetFormControl;
    public endDate!: DateTimeOffsetFormControl;
    public description!: StringFormControl;
    public statistics!: WeatherEventStatisticsFormGuide;
    public locations!: WeatherEventLocationFormGuide[];
    public alerts!: WeatherEventAlertFormGuide[];

    constructor(data?: IWeatherEventFormGuide) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.name = data.name && !(<any>data.name).toJSON ? new StringFormControl(data.name) : <StringFormControl>this.name;
            this.experience = data.experience && !(<any>data.experience).toJSON ? new WeatherExperienceFormControl(data.experience) : <WeatherExperienceFormControl>this.experience;
            this.weather = data.weather && !(<any>data.weather).toJSON ? new WeatherFormControl(data.weather) : <WeatherFormControl>this.weather;
            this.startDate = data.startDate && !(<any>data.startDate).toJSON ? new DateTimeOffsetFormControl(data.startDate) : <DateTimeOffsetFormControl>this.startDate;
            this.endDate = data.endDate && !(<any>data.endDate).toJSON ? new DateTimeOffsetFormControl(data.endDate) : <DateTimeOffsetFormControl>this.endDate;
            this.description = data.description && !(<any>data.description).toJSON ? new StringFormControl(data.description) : <StringFormControl>this.description;
            this.statistics = data.statistics && !(<any>data.statistics).toJSON ? new WeatherEventStatisticsFormGuide(data.statistics) : <WeatherEventStatisticsFormGuide>this.statistics;
            if (data.locations) {
                this.locations = [];
                for (let i = 0; i < data.locations.length; i++) {
                    let item = data.locations[i];
                    this.locations[i] = item && !(<any>item).toJSON ? new WeatherEventLocationFormGuide(item) : <WeatherEventLocationFormGuide>item;
                }
            }
            if (data.alerts) {
                this.alerts = [];
                for (let i = 0; i < data.alerts.length; i++) {
                    let item = data.alerts[i];
                    this.alerts[i] = item && !(<any>item).toJSON ? new WeatherEventAlertFormGuide(item) : <WeatherEventAlertFormGuide>item;
                }
            }
        }
        if (!data) {
            this.name = new StringFormControl();
            this.experience = new WeatherExperienceFormControl();
            this.weather = new WeatherFormControl();
            this.startDate = new DateTimeOffsetFormControl();
            this.endDate = new DateTimeOffsetFormControl();
            this.description = new StringFormControl();
            this.statistics = new WeatherEventStatisticsFormGuide();
            this.locations = [];
            this.alerts = [];
        }
    }

    /**
    * Initializes a new WeatherEventFormGuide instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherEventFormGuide.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.name = _data["name"] ? StringFormControl.fromJS(_data["name"]) : new StringFormControl();
            this.experience = _data["experience"] ? WeatherExperienceFormControl.fromJS(_data["experience"]) : new WeatherExperienceFormControl();
            this.weather = _data["weather"] ? WeatherFormControl.fromJS(_data["weather"]) : new WeatherFormControl();
            this.startDate = _data["startDate"] ? DateTimeOffsetFormControl.fromJS(_data["startDate"]) : new DateTimeOffsetFormControl();
            this.endDate = _data["endDate"] ? DateTimeOffsetFormControl.fromJS(_data["endDate"]) : new DateTimeOffsetFormControl();
            this.description = _data["description"] ? StringFormControl.fromJS(_data["description"]) : new StringFormControl();
            this.statistics = _data["statistics"] ? WeatherEventStatisticsFormGuide.fromJS(_data["statistics"]) : new WeatherEventStatisticsFormGuide();
            if (Array.isArray(_data["locations"])) {
                this.locations = [] as any;
                for (let item of _data["locations"])
                    this.locations!.push(WeatherEventLocationFormGuide.fromJS(item));
            }
            else {
                this.locations = <any>null;
            }
            if (Array.isArray(_data["alerts"])) {
                this.alerts = [] as any;
                for (let item of _data["alerts"])
                    this.alerts!.push(WeatherEventAlertFormGuide.fromJS(item));
            }
            else {
                this.alerts = <any>null;
            }
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherEventFormGuide.
    * @param data Any object that holds the necessary properties to initialize a new WeatherEventFormGuide.
    * @returns A deserialized WeatherEventFormGuide.
    **/
    public static fromJS(data: any): WeatherEventFormGuide {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherEventFormGuide();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherEventFormGuide.
    * @returns A serialized WeatherEventFormGuide.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>null;
        data["experience"] = this.experience ? this.experience.toJSON() : <any>null;
        data["weather"] = this.weather ? this.weather.toJSON() : <any>null;
        data["startDate"] = this.startDate ? this.startDate.toJSON() : <any>null;
        data["endDate"] = this.endDate ? this.endDate.toJSON() : <any>null;
        data["description"] = this.description ? this.description.toJSON() : <any>null;
        data["statistics"] = this.statistics ? this.statistics.toJSON() : <any>null;
        if (Array.isArray(this.locations)) {
            data["locations"] = [];
            for (let item of this.locations)
                data["locations"].push(item.toJSON());
        }
        if (Array.isArray(this.alerts)) {
            data["alerts"] = [];
            for (let item of this.alerts)
                data["alerts"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWeatherEventFormGuide {
    name: IStringFormControl;
    experience: IWeatherExperienceFormControl;
    weather: IWeatherFormControl;
    startDate: IDateTimeOffsetFormControl;
    endDate: IDateTimeOffsetFormControl;
    description: IStringFormControl;
    statistics: IWeatherEventStatisticsFormGuide;
    locations: IWeatherEventLocationFormGuide[];
    alerts: IWeatherEventAlertFormGuide[];
}

export class WeatherEventFormGuideRequest implements IWeatherEventFormGuideRequest {
    public model!: WeatherEvent;
    public context!: FormGuideContext;

    constructor(data?: IWeatherEventFormGuideRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.model = data.model && !(<any>data.model).toJSON ? new WeatherEvent(data.model) : <WeatherEvent>this.model;
            this.context = data.context && !(<any>data.context).toJSON ? new FormGuideContext(data.context) : <FormGuideContext>this.context;
        }
        if (!data) {
            this.model = new WeatherEvent();
            this.context = new FormGuideContext();
        }
    }

    /**
    * Initializes a new WeatherEventFormGuideRequest instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherEventFormGuideRequest.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.model = _data["model"] ? WeatherEvent.fromJS(_data["model"]) : new WeatherEvent();
            this.context = _data["context"] ? FormGuideContext.fromJS(_data["context"]) : new FormGuideContext();
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherEventFormGuideRequest.
    * @param data Any object that holds the necessary properties to initialize a new WeatherEventFormGuideRequest.
    * @returns A deserialized WeatherEventFormGuideRequest.
    **/
    public static fromJS(data: any): WeatherEventFormGuideRequest {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherEventFormGuideRequest();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherEventFormGuideRequest.
    * @returns A serialized WeatherEventFormGuideRequest.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["model"] = this.model ? this.model.toJSON() : <any>null;
        data["context"] = this.context ? this.context.toJSON() : <any>null;
        return data;
    }
}

export interface IWeatherEventFormGuideRequest {
    model: IWeatherEvent;
    context: IFormGuideContext;
}

export class WeatherEventLocation implements IWeatherEventLocation {
    public id?: number | null;
    public deleted!: boolean;
    public location!: Location;
    public startTime!: Date;
    public endTime!: Date;

    constructor(data?: IWeatherEventLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.location = data.location && !(<any>data.location).toJSON ? new Location(data.location) : <Location>this.location;
        }
        if (!data) {
            this.location = new Location();
        }
    }

    /**
    * Initializes a new WeatherEventLocation instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherEventLocation.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
            this.location = _data["location"] ? Location.fromJS(_data["location"]) : new Location();
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>null;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherEventLocation.
    * @param data Any object that holds the necessary properties to initialize a new WeatherEventLocation.
    * @returns A deserialized WeatherEventLocation.
    **/
    public static fromJS(data: any): WeatherEventLocation {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherEventLocation();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherEventLocation.
    * @returns A serialized WeatherEventLocation.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["location"] = this.location ? this.location.toJSON() : <any>null;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>null;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>null;
        return data;
    }
}

export interface IWeatherEventLocation {
    id?: number | null;
    deleted: boolean;
    location: ILocation;
    startTime: Date;
    endTime: Date;
}

export class WeatherEventLocationFormGuide implements IWeatherEventLocationFormGuide {
    public startTime!: DateTimeOffsetFormControl;
    public endTime!: DateTimeOffsetFormControl;
    public location!: LocationFormGuide;

    constructor(data?: IWeatherEventLocationFormGuide) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.startTime = data.startTime && !(<any>data.startTime).toJSON ? new DateTimeOffsetFormControl(data.startTime) : <DateTimeOffsetFormControl>this.startTime;
            this.endTime = data.endTime && !(<any>data.endTime).toJSON ? new DateTimeOffsetFormControl(data.endTime) : <DateTimeOffsetFormControl>this.endTime;
            this.location = data.location && !(<any>data.location).toJSON ? new LocationFormGuide(data.location) : <LocationFormGuide>this.location;
        }
        if (!data) {
            this.startTime = new DateTimeOffsetFormControl();
            this.endTime = new DateTimeOffsetFormControl();
            this.location = new LocationFormGuide();
        }
    }

    /**
    * Initializes a new WeatherEventLocationFormGuide instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherEventLocationFormGuide.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.startTime = _data["startTime"] ? DateTimeOffsetFormControl.fromJS(_data["startTime"]) : new DateTimeOffsetFormControl();
            this.endTime = _data["endTime"] ? DateTimeOffsetFormControl.fromJS(_data["endTime"]) : new DateTimeOffsetFormControl();
            this.location = _data["location"] ? LocationFormGuide.fromJS(_data["location"]) : new LocationFormGuide();
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherEventLocationFormGuide.
    * @param data Any object that holds the necessary properties to initialize a new WeatherEventLocationFormGuide.
    * @returns A deserialized WeatherEventLocationFormGuide.
    **/
    public static fromJS(data: any): WeatherEventLocationFormGuide {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherEventLocationFormGuide();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherEventLocationFormGuide.
    * @returns A serialized WeatherEventLocationFormGuide.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toJSON() : <any>null;
        data["endTime"] = this.endTime ? this.endTime.toJSON() : <any>null;
        data["location"] = this.location ? this.location.toJSON() : <any>null;
        return data;
    }
}

export interface IWeatherEventLocationFormGuide {
    startTime: IDateTimeOffsetFormControl;
    endTime: IDateTimeOffsetFormControl;
    location: ILocationFormGuide;
}

export class WeatherEventStatistics implements IWeatherEventStatistics {
    public id?: number | null;
    public deleted!: boolean;
    public damageCost?: number | null;
    public fatalities?: number | null;
    public efRating?: number | null;
    public pathDistance?: number | null;
    public funnelWidth?: number | null;
    public saffirSimpsonRating?: number | null;
    public lowestPressure?: number | null;
    public maxWindSpeed?: number | null;
    public richterMagnitude?: number | null;
    public mercalliIntensity?: number | null;
    public aftershocks?: number | null;
    public fault?: string | null;
    public relatedTsunami?: boolean | null;

    constructor(data?: IWeatherEventStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new WeatherEventStatistics instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherEventStatistics.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
            this.damageCost = _data["damageCost"] !== undefined ? _data["damageCost"] : <any>null;
            this.fatalities = _data["fatalities"] !== undefined ? _data["fatalities"] : <any>null;
            this.efRating = _data["efRating"] !== undefined ? _data["efRating"] : <any>null;
            this.pathDistance = _data["pathDistance"] !== undefined ? _data["pathDistance"] : <any>null;
            this.funnelWidth = _data["funnelWidth"] !== undefined ? _data["funnelWidth"] : <any>null;
            this.saffirSimpsonRating = _data["saffirSimpsonRating"] !== undefined ? _data["saffirSimpsonRating"] : <any>null;
            this.lowestPressure = _data["lowestPressure"] !== undefined ? _data["lowestPressure"] : <any>null;
            this.maxWindSpeed = _data["maxWindSpeed"] !== undefined ? _data["maxWindSpeed"] : <any>null;
            this.richterMagnitude = _data["richterMagnitude"] !== undefined ? _data["richterMagnitude"] : <any>null;
            this.mercalliIntensity = _data["mercalliIntensity"] !== undefined ? _data["mercalliIntensity"] : <any>null;
            this.aftershocks = _data["aftershocks"] !== undefined ? _data["aftershocks"] : <any>null;
            this.fault = _data["fault"] !== undefined ? _data["fault"] : <any>null;
            this.relatedTsunami = _data["relatedTsunami"] !== undefined ? _data["relatedTsunami"] : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherEventStatistics.
    * @param data Any object that holds the necessary properties to initialize a new WeatherEventStatistics.
    * @returns A deserialized WeatherEventStatistics.
    **/
    public static fromJS(data: any): WeatherEventStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherEventStatistics();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherEventStatistics.
    * @returns A serialized WeatherEventStatistics.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["damageCost"] = this.damageCost !== undefined ? this.damageCost : <any>null;
        data["fatalities"] = this.fatalities !== undefined ? this.fatalities : <any>null;
        data["efRating"] = this.efRating !== undefined ? this.efRating : <any>null;
        data["pathDistance"] = this.pathDistance !== undefined ? this.pathDistance : <any>null;
        data["funnelWidth"] = this.funnelWidth !== undefined ? this.funnelWidth : <any>null;
        data["saffirSimpsonRating"] = this.saffirSimpsonRating !== undefined ? this.saffirSimpsonRating : <any>null;
        data["lowestPressure"] = this.lowestPressure !== undefined ? this.lowestPressure : <any>null;
        data["maxWindSpeed"] = this.maxWindSpeed !== undefined ? this.maxWindSpeed : <any>null;
        data["richterMagnitude"] = this.richterMagnitude !== undefined ? this.richterMagnitude : <any>null;
        data["mercalliIntensity"] = this.mercalliIntensity !== undefined ? this.mercalliIntensity : <any>null;
        data["aftershocks"] = this.aftershocks !== undefined ? this.aftershocks : <any>null;
        data["fault"] = this.fault !== undefined ? this.fault : <any>null;
        data["relatedTsunami"] = this.relatedTsunami !== undefined ? this.relatedTsunami : <any>null;
        return data;
    }
}

export interface IWeatherEventStatistics {
    id?: number | null;
    deleted: boolean;
    damageCost?: number | null;
    fatalities?: number | null;
    efRating?: number | null;
    pathDistance?: number | null;
    funnelWidth?: number | null;
    saffirSimpsonRating?: number | null;
    lowestPressure?: number | null;
    maxWindSpeed?: number | null;
    richterMagnitude?: number | null;
    mercalliIntensity?: number | null;
    aftershocks?: number | null;
    fault?: string | null;
    relatedTsunami?: boolean | null;
}

export class WeatherEventStatisticsFormGuide implements IWeatherEventStatisticsFormGuide {
    public damageCost!: Int32FormControl;
    public fatalities!: Int32FormControl;
    public efRating!: Int32FormControl;
    public pathDistance!: Int32FormControl;
    public funnelWidth!: Int32FormControl;
    public saffirSimpsonRating!: Int32FormControl;
    public lowestPressure!: Int32FormControl;
    public maxWindSpeed!: Int32FormControl;
    public richterMagnitude!: SingleFormControl;
    public mercalliIntensity!: Int32FormControl;
    public aftershocks!: Int32FormControl;
    public fault!: StringFormControl;
    public relatedTsunami!: BooleanFormControl;

    constructor(data?: IWeatherEventStatisticsFormGuide) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.damageCost = data.damageCost && !(<any>data.damageCost).toJSON ? new Int32FormControl(data.damageCost) : <Int32FormControl>this.damageCost;
            this.fatalities = data.fatalities && !(<any>data.fatalities).toJSON ? new Int32FormControl(data.fatalities) : <Int32FormControl>this.fatalities;
            this.efRating = data.efRating && !(<any>data.efRating).toJSON ? new Int32FormControl(data.efRating) : <Int32FormControl>this.efRating;
            this.pathDistance = data.pathDistance && !(<any>data.pathDistance).toJSON ? new Int32FormControl(data.pathDistance) : <Int32FormControl>this.pathDistance;
            this.funnelWidth = data.funnelWidth && !(<any>data.funnelWidth).toJSON ? new Int32FormControl(data.funnelWidth) : <Int32FormControl>this.funnelWidth;
            this.saffirSimpsonRating = data.saffirSimpsonRating && !(<any>data.saffirSimpsonRating).toJSON ? new Int32FormControl(data.saffirSimpsonRating) : <Int32FormControl>this.saffirSimpsonRating;
            this.lowestPressure = data.lowestPressure && !(<any>data.lowestPressure).toJSON ? new Int32FormControl(data.lowestPressure) : <Int32FormControl>this.lowestPressure;
            this.maxWindSpeed = data.maxWindSpeed && !(<any>data.maxWindSpeed).toJSON ? new Int32FormControl(data.maxWindSpeed) : <Int32FormControl>this.maxWindSpeed;
            this.richterMagnitude = data.richterMagnitude && !(<any>data.richterMagnitude).toJSON ? new SingleFormControl(data.richterMagnitude) : <SingleFormControl>this.richterMagnitude;
            this.mercalliIntensity = data.mercalliIntensity && !(<any>data.mercalliIntensity).toJSON ? new Int32FormControl(data.mercalliIntensity) : <Int32FormControl>this.mercalliIntensity;
            this.aftershocks = data.aftershocks && !(<any>data.aftershocks).toJSON ? new Int32FormControl(data.aftershocks) : <Int32FormControl>this.aftershocks;
            this.fault = data.fault && !(<any>data.fault).toJSON ? new StringFormControl(data.fault) : <StringFormControl>this.fault;
            this.relatedTsunami = data.relatedTsunami && !(<any>data.relatedTsunami).toJSON ? new BooleanFormControl(data.relatedTsunami) : <BooleanFormControl>this.relatedTsunami;
        }
        if (!data) {
            this.damageCost = new Int32FormControl();
            this.fatalities = new Int32FormControl();
            this.efRating = new Int32FormControl();
            this.pathDistance = new Int32FormControl();
            this.funnelWidth = new Int32FormControl();
            this.saffirSimpsonRating = new Int32FormControl();
            this.lowestPressure = new Int32FormControl();
            this.maxWindSpeed = new Int32FormControl();
            this.richterMagnitude = new SingleFormControl();
            this.mercalliIntensity = new Int32FormControl();
            this.aftershocks = new Int32FormControl();
            this.fault = new StringFormControl();
            this.relatedTsunami = new BooleanFormControl();
        }
    }

    /**
    * Initializes a new WeatherEventStatisticsFormGuide instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherEventStatisticsFormGuide.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.damageCost = _data["damageCost"] ? Int32FormControl.fromJS(_data["damageCost"]) : new Int32FormControl();
            this.fatalities = _data["fatalities"] ? Int32FormControl.fromJS(_data["fatalities"]) : new Int32FormControl();
            this.efRating = _data["efRating"] ? Int32FormControl.fromJS(_data["efRating"]) : new Int32FormControl();
            this.pathDistance = _data["pathDistance"] ? Int32FormControl.fromJS(_data["pathDistance"]) : new Int32FormControl();
            this.funnelWidth = _data["funnelWidth"] ? Int32FormControl.fromJS(_data["funnelWidth"]) : new Int32FormControl();
            this.saffirSimpsonRating = _data["saffirSimpsonRating"] ? Int32FormControl.fromJS(_data["saffirSimpsonRating"]) : new Int32FormControl();
            this.lowestPressure = _data["lowestPressure"] ? Int32FormControl.fromJS(_data["lowestPressure"]) : new Int32FormControl();
            this.maxWindSpeed = _data["maxWindSpeed"] ? Int32FormControl.fromJS(_data["maxWindSpeed"]) : new Int32FormControl();
            this.richterMagnitude = _data["richterMagnitude"] ? SingleFormControl.fromJS(_data["richterMagnitude"]) : new SingleFormControl();
            this.mercalliIntensity = _data["mercalliIntensity"] ? Int32FormControl.fromJS(_data["mercalliIntensity"]) : new Int32FormControl();
            this.aftershocks = _data["aftershocks"] ? Int32FormControl.fromJS(_data["aftershocks"]) : new Int32FormControl();
            this.fault = _data["fault"] ? StringFormControl.fromJS(_data["fault"]) : new StringFormControl();
            this.relatedTsunami = _data["relatedTsunami"] ? BooleanFormControl.fromJS(_data["relatedTsunami"]) : new BooleanFormControl();
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherEventStatisticsFormGuide.
    * @param data Any object that holds the necessary properties to initialize a new WeatherEventStatisticsFormGuide.
    * @returns A deserialized WeatherEventStatisticsFormGuide.
    **/
    public static fromJS(data: any): WeatherEventStatisticsFormGuide {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherEventStatisticsFormGuide();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherEventStatisticsFormGuide.
    * @returns A serialized WeatherEventStatisticsFormGuide.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["damageCost"] = this.damageCost ? this.damageCost.toJSON() : <any>null;
        data["fatalities"] = this.fatalities ? this.fatalities.toJSON() : <any>null;
        data["efRating"] = this.efRating ? this.efRating.toJSON() : <any>null;
        data["pathDistance"] = this.pathDistance ? this.pathDistance.toJSON() : <any>null;
        data["funnelWidth"] = this.funnelWidth ? this.funnelWidth.toJSON() : <any>null;
        data["saffirSimpsonRating"] = this.saffirSimpsonRating ? this.saffirSimpsonRating.toJSON() : <any>null;
        data["lowestPressure"] = this.lowestPressure ? this.lowestPressure.toJSON() : <any>null;
        data["maxWindSpeed"] = this.maxWindSpeed ? this.maxWindSpeed.toJSON() : <any>null;
        data["richterMagnitude"] = this.richterMagnitude ? this.richterMagnitude.toJSON() : <any>null;
        data["mercalliIntensity"] = this.mercalliIntensity ? this.mercalliIntensity.toJSON() : <any>null;
        data["aftershocks"] = this.aftershocks ? this.aftershocks.toJSON() : <any>null;
        data["fault"] = this.fault ? this.fault.toJSON() : <any>null;
        data["relatedTsunami"] = this.relatedTsunami ? this.relatedTsunami.toJSON() : <any>null;
        return data;
    }
}

export interface IWeatherEventStatisticsFormGuide {
    damageCost: IInt32FormControl;
    fatalities: IInt32FormControl;
    efRating: IInt32FormControl;
    pathDistance: IInt32FormControl;
    funnelWidth: IInt32FormControl;
    saffirSimpsonRating: IInt32FormControl;
    lowestPressure: IInt32FormControl;
    maxWindSpeed: IInt32FormControl;
    richterMagnitude: ISingleFormControl;
    mercalliIntensity: IInt32FormControl;
    aftershocks: IInt32FormControl;
    fault: IStringFormControl;
    relatedTsunami: IBooleanFormControl;
}

export class WeatherExperience implements IWeatherExperience {
    public id?: number | null;
    public deleted!: boolean;
    public name!: string;
    public description!: string;
    public startTime!: Date;
    public endTime?: Date | null;

    constructor(data?: IWeatherExperience) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    /**
    * Initializes a new WeatherExperience instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherExperience.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>null;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>null;
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherExperience.
    * @param data Any object that holds the necessary properties to initialize a new WeatherExperience.
    * @returns A deserialized WeatherExperience.
    **/
    public static fromJS(data: any): WeatherExperience {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherExperience();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherExperience.
    * @returns A serialized WeatherExperience.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>null;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>null;
        return data;
    }
}

export interface IWeatherExperience {
    id?: number | null;
    deleted: boolean;
    name: string;
    description: string;
    startTime: Date;
    endTime?: Date | null;
}

export class WeatherExperienceFormControl implements IWeatherExperienceFormControl {
    public validation!: FormControlValidation;
    public readOnly!: boolean;
    public hidden!: boolean;
    public defaultValue!: WeatherExperience;
    public suppliedValues!: WeatherExperienceFormControlValue[];

    constructor(data?: IWeatherExperienceFormControl) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.validation = data.validation && !(<any>data.validation).toJSON ? new FormControlValidation(data.validation) : <FormControlValidation>this.validation;
            this.defaultValue = data.defaultValue && !(<any>data.defaultValue).toJSON ? new WeatherExperience(data.defaultValue) : <WeatherExperience>this.defaultValue;
            if (data.suppliedValues) {
                this.suppliedValues = [];
                for (let i = 0; i < data.suppliedValues.length; i++) {
                    let item = data.suppliedValues[i];
                    this.suppliedValues[i] = item && !(<any>item).toJSON ? new WeatherExperienceFormControlValue(item) : <WeatherExperienceFormControlValue>item;
                }
            }
        }
        if (!data) {
            this.validation = new FormControlValidation();
            this.defaultValue = new WeatherExperience();
            this.suppliedValues = [];
        }
    }

    /**
    * Initializes a new WeatherExperienceFormControl instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherExperienceFormControl.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.validation = _data["validation"] ? FormControlValidation.fromJS(_data["validation"]) : new FormControlValidation();
            this.readOnly = _data["readOnly"] !== undefined ? _data["readOnly"] : <any>null;
            this.hidden = _data["hidden"] !== undefined ? _data["hidden"] : <any>null;
            this.defaultValue = _data["defaultValue"] ? WeatherExperience.fromJS(_data["defaultValue"]) : new WeatherExperience();
            if (Array.isArray(_data["suppliedValues"])) {
                this.suppliedValues = [] as any;
                for (let item of _data["suppliedValues"])
                    this.suppliedValues!.push(WeatherExperienceFormControlValue.fromJS(item));
            }
            else {
                this.suppliedValues = <any>null;
            }
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherExperienceFormControl.
    * @param data Any object that holds the necessary properties to initialize a new WeatherExperienceFormControl.
    * @returns A deserialized WeatherExperienceFormControl.
    **/
    public static fromJS(data: any): WeatherExperienceFormControl {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherExperienceFormControl();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherExperienceFormControl.
    * @returns A serialized WeatherExperienceFormControl.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["validation"] = this.validation ? this.validation.toJSON() : <any>null;
        data["readOnly"] = this.readOnly !== undefined ? this.readOnly : <any>null;
        data["hidden"] = this.hidden !== undefined ? this.hidden : <any>null;
        data["defaultValue"] = this.defaultValue ? this.defaultValue.toJSON() : <any>null;
        if (Array.isArray(this.suppliedValues)) {
            data["suppliedValues"] = [];
            for (let item of this.suppliedValues)
                data["suppliedValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWeatherExperienceFormControl {
    validation: IFormControlValidation;
    readOnly: boolean;
    hidden: boolean;
    defaultValue: IWeatherExperience;
    suppliedValues: IWeatherExperienceFormControlValue[];
}

export class WeatherExperienceFormControlValue implements IWeatherExperienceFormControlValue {
    public name!: string;
    public value!: WeatherExperience;

    constructor(data?: IWeatherExperienceFormControlValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.value = data.value && !(<any>data.value).toJSON ? new WeatherExperience(data.value) : <WeatherExperience>this.value;
        }
        if (!data) {
            this.value = new WeatherExperience();
        }
    }

    /**
    * Initializes a new WeatherExperienceFormControlValue instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherExperienceFormControlValue.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.value = _data["value"] ? WeatherExperience.fromJS(_data["value"]) : new WeatherExperience();
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherExperienceFormControlValue.
    * @param data Any object that holds the necessary properties to initialize a new WeatherExperienceFormControlValue.
    * @returns A deserialized WeatherExperienceFormControlValue.
    **/
    public static fromJS(data: any): WeatherExperienceFormControlValue {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherExperienceFormControlValue();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherExperienceFormControlValue.
    * @returns A serialized WeatherExperienceFormControlValue.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["value"] = this.value ? this.value.toJSON() : <any>null;
        return data;
    }
}

export interface IWeatherExperienceFormControlValue {
    name: string;
    value: IWeatherExperience;
}

export class WeatherFormControl implements IWeatherFormControl {
    public validation!: FormControlValidation;
    public readOnly!: boolean;
    public hidden!: boolean;
    public defaultValue!: Weather;
    public suppliedValues!: WeatherFormControlValue[];

    constructor(data?: IWeatherFormControl) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.validation = data.validation && !(<any>data.validation).toJSON ? new FormControlValidation(data.validation) : <FormControlValidation>this.validation;
            this.defaultValue = data.defaultValue && !(<any>data.defaultValue).toJSON ? new Weather(data.defaultValue) : <Weather>this.defaultValue;
            if (data.suppliedValues) {
                this.suppliedValues = [];
                for (let i = 0; i < data.suppliedValues.length; i++) {
                    let item = data.suppliedValues[i];
                    this.suppliedValues[i] = item && !(<any>item).toJSON ? new WeatherFormControlValue(item) : <WeatherFormControlValue>item;
                }
            }
        }
        if (!data) {
            this.validation = new FormControlValidation();
            this.defaultValue = new Weather();
            this.suppliedValues = [];
        }
    }

    /**
    * Initializes a new WeatherFormControl instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherFormControl.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.validation = _data["validation"] ? FormControlValidation.fromJS(_data["validation"]) : new FormControlValidation();
            this.readOnly = _data["readOnly"] !== undefined ? _data["readOnly"] : <any>null;
            this.hidden = _data["hidden"] !== undefined ? _data["hidden"] : <any>null;
            this.defaultValue = _data["defaultValue"] ? Weather.fromJS(_data["defaultValue"]) : new Weather();
            if (Array.isArray(_data["suppliedValues"])) {
                this.suppliedValues = [] as any;
                for (let item of _data["suppliedValues"])
                    this.suppliedValues!.push(WeatherFormControlValue.fromJS(item));
            }
            else {
                this.suppliedValues = <any>null;
            }
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherFormControl.
    * @param data Any object that holds the necessary properties to initialize a new WeatherFormControl.
    * @returns A deserialized WeatherFormControl.
    **/
    public static fromJS(data: any): WeatherFormControl {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherFormControl();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherFormControl.
    * @returns A serialized WeatherFormControl.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["validation"] = this.validation ? this.validation.toJSON() : <any>null;
        data["readOnly"] = this.readOnly !== undefined ? this.readOnly : <any>null;
        data["hidden"] = this.hidden !== undefined ? this.hidden : <any>null;
        data["defaultValue"] = this.defaultValue ? this.defaultValue.toJSON() : <any>null;
        if (Array.isArray(this.suppliedValues)) {
            data["suppliedValues"] = [];
            for (let item of this.suppliedValues)
                data["suppliedValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWeatherFormControl {
    validation: IFormControlValidation;
    readOnly: boolean;
    hidden: boolean;
    defaultValue: IWeather;
    suppliedValues: IWeatherFormControlValue[];
}

export class WeatherFormControlValue implements IWeatherFormControlValue {
    public name!: string;
    public value!: Weather;

    constructor(data?: IWeatherFormControlValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.value = data.value && !(<any>data.value).toJSON ? new Weather(data.value) : <Weather>this.value;
        }
        if (!data) {
            this.value = new Weather();
        }
    }

    /**
    * Initializes a new WeatherFormControlValue instance from the specified data.
    * This method is used in the serialization/deserialization process and allows for overriding in subclasses. 
    * @param _data Any object that holds the necessary properties to initialize a new WeatherFormControlValue.
    **/
    protected init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.value = _data["value"] ? Weather.fromJS(_data["value"]) : new Weather();
        }
    }

    /**
    * Deserializes a JSON representation of this WeatherFormControlValue.
    * @param data Any object that holds the necessary properties to initialize a new WeatherFormControlValue.
    * @returns A deserialized WeatherFormControlValue.
    **/
    public static fromJS(data: any): WeatherFormControlValue {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherFormControlValue();
        result.init(data);
        return result;
    }

    /**
    * Serializes a JSON representation of this WeatherFormControlValue.
    * @returns A serialized WeatherFormControlValue.
    **/
    public toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["value"] = this.value ? this.value.toJSON() : <any>null;
        return data;
    }
}

export interface IWeatherFormControlValue {
    name: string;
    value: IWeather;
}

export class SkylightApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSkylightApiException = true;

    static isSkylightApiException(obj: any): obj is SkylightApiException {
        return obj.isSkylightApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SkylightApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}

// Put any type imports required for Http Clients generated by NSwag here...