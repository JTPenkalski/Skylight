//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.3.0.0 (NJsonSchema v11.2.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class SkylightClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
			this.http = http ? http : window as any;
			this.baseUrl = baseUrl ?? "https://localhost:7266/";
	}

	/**
	 * @return OK
	 */
	addCurrentAlerts(body: AddCurrentAlertsCommand): Promise<AddCurrentAlertsResponse> {
			let url_ = this.baseUrl + "/api/v1/Alerts/AddCurrentAlerts";
			url_ = url_.replace(/[?&]$/, "");

			const content_ = JSON.stringify(body);

			let options_: RequestInit = {
					body: content_,
					method: "POST",
					headers: {
							"Content-Type": "application/json",
							"Accept": "application/json"
					}
			};

			return this.http.fetch(url_, options_).then((_response: Response) => {
					return this.processAddCurrentAlerts(_response);
			});
	}

	protected processAddCurrentAlerts(response: Response): Promise<AddCurrentAlertsResponse> {
			const status = response.status;
			let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
			if (status === 200) {
					return response.text().then((_responseText) => {
					let result200: any = null;
					result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AddCurrentAlertsResponse;
					return result200;
					});
			} else if (status !== 200 && status !== 204) {
					return response.text().then((_responseText) => {
					return throwException("An unexpected server error occurred.", status, _responseText, _headers);
					});
			}
			return Promise.resolve<AddCurrentAlertsResponse>(null as any);
	}

	/**
	 * @return OK
	 */
	getCurrentAlertsByType(body: GetCurrentAlertsByTypeQuery): Promise<GetCurrentAlertsByTypeResponse> {
			let url_ = this.baseUrl + "/api/v1/Alerts/GetCurrentAlertsByType";
			url_ = url_.replace(/[?&]$/, "");

			const content_ = JSON.stringify(body);

			let options_: RequestInit = {
					body: content_,
					method: "POST",
					headers: {
							"Content-Type": "application/json",
							"Accept": "application/json"
					}
			};

			return this.http.fetch(url_, options_).then((_response: Response) => {
					return this.processGetCurrentAlertsByType(_response);
			});
	}

	protected processGetCurrentAlertsByType(response: Response): Promise<GetCurrentAlertsByTypeResponse> {
			const status = response.status;
			let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
			if (status === 200) {
					return response.text().then((_responseText) => {
					let result200: any = null;
					result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetCurrentAlertsByTypeResponse;
					return result200;
					});
			} else if (status !== 200 && status !== 204) {
					return response.text().then((_responseText) => {
					return throwException("An unexpected server error occurred.", status, _responseText, _headers);
					});
			}
			return Promise.resolve<GetCurrentAlertsByTypeResponse>(null as any);
	}

	/**
	 * @return OK
	 */
	getAlertSenders(body: GetAlertSendersQuery): Promise<GetAlertSendersResponse> {
			let url_ = this.baseUrl + "/api/v1/Alerts/GetAlertSenders";
			url_ = url_.replace(/[?&]$/, "");

			const content_ = JSON.stringify(body);

			let options_: RequestInit = {
					body: content_,
					method: "POST",
					headers: {
							"Content-Type": "application/json",
							"Accept": "application/json"
					}
			};

			return this.http.fetch(url_, options_).then((_response: Response) => {
					return this.processGetAlertSenders(_response);
			});
	}

	protected processGetAlertSenders(response: Response): Promise<GetAlertSendersResponse> {
			const status = response.status;
			let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
			if (status === 200) {
					return response.text().then((_responseText) => {
					let result200: any = null;
					result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetAlertSendersResponse;
					return result200;
					});
			} else if (status !== 200 && status !== 204) {
					return response.text().then((_responseText) => {
					return throwException("An unexpected server error occurred.", status, _responseText, _headers);
					});
			}
			return Promise.resolve<GetAlertSendersResponse>(null as any);
	}

	/**
	 * @return OK
	 */
	getAlertTypes(body: GetAlertTypesQuery): Promise<GetAlertTypesResponse> {
			let url_ = this.baseUrl + "/api/v1/Alerts/GetAlertTypes";
			url_ = url_.replace(/[?&]$/, "");

			const content_ = JSON.stringify(body);

			let options_: RequestInit = {
					body: content_,
					method: "POST",
					headers: {
							"Content-Type": "application/json",
							"Accept": "application/json"
					}
			};

			return this.http.fetch(url_, options_).then((_response: Response) => {
					return this.processGetAlertTypes(_response);
			});
	}

	protected processGetAlertTypes(response: Response): Promise<GetAlertTypesResponse> {
			const status = response.status;
			let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
			if (status === 200) {
					return response.text().then((_responseText) => {
					let result200: any = null;
					result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetAlertTypesResponse;
					return result200;
					});
			} else if (status !== 200 && status !== 204) {
					return response.text().then((_responseText) => {
					return throwException("An unexpected server error occurred.", status, _responseText, _headers);
					});
			}
			return Promise.resolve<GetAlertTypesResponse>(null as any);
	}
}

export interface AddCurrentAlertsCommand {

	[key: string]: any;
}

export interface AddCurrentAlertsResponse {
	currentAlerts: CurrentAlert[];

	[key: string]: any;
}

export interface AlertSender {
	code: string;
	name: string;

	[key: string]: any;
}

export interface AlertType {
	code: string;
	name: string;
	description: string;
	level: string;

	[key: string]: any;
}

export interface CurrentAlert {
	alertCode: string;
	alertName: string;
	alertLevel: number;
	senderCode: string;
	senderName: string;
	headline: string;
	description: string;
	instruction: string;
	sent: Date;
	effective: Date;
	expires: Date;
	type: number;
	severity: number;
	certainty: number;
	urgency: number;
	response: number;
	zones: string[];

	[key: string]: any;
}

export interface CurrentAlertByType {
	alertCode: string;
	alertName: string;
	alertLevel: number;
	senderCode: string;
	senderName: string;
	headline: string;
	description: string;
	instruction: string;
	sent: Date;
	effective: Date;
	expires: Date;
	type: number;
	severity: number;
	certainty: number;
	urgency: number;
	response: number;
	zones: string[];

	[key: string]: any;
}

export interface GetAlertSendersQuery {

	[key: string]: any;
}

export interface GetAlertSendersResponse {
	senders: AlertSender[];

	[key: string]: any;
}

export interface GetAlertTypesQuery {

	[key: string]: any;
}

export interface GetAlertTypesResponse {
	types: AlertType[];

	[key: string]: any;
}

export interface GetCurrentAlertsByTypeQuery {
	code: string;

	[key: string]: any;
}

export interface GetCurrentAlertsByTypeResponse {
	currentAlerts: CurrentAlertByType[];

	[key: string]: any;
}

export class ApiException extends Error {
	override message: string;
	status: number;
	response: string;
	headers: { [key: string]: any; };
	result: any;

	constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
			super();

			this.message = message;
			this.status = status;
			this.response = response;
			this.headers = headers;
			this.result = result;
	}

	protected isApiException = true;

	static isApiException(obj: any): obj is ApiException {
			return obj.isApiException === true;
	}
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
	if (result !== null && result !== undefined)
			throw result;
	else
			throw new ApiException(message, status, response, headers, null);
}
